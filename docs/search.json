[
  {
    "objectID": "session5.html",
    "href": "session5.html",
    "title": "Analyse af strategiske netværksroller",
    "section": "",
    "text": "I denne session bygger vi videre på nogle af koncenterne fra sidst (centralitet se Session3, transitivitet, netværks-lukning og strukturelle huller se Session4)\nFørst indlæser vi de pakker vi skal bruge:\nSom tidligere kan I downloade opdaterede R scripts med hjælpe-funktioner her Download costum_functions.R her\nDownload networkfunctions.R her\nDe skal lige ‘sources’ så funktionerne ligger i vores global environment\nsource(\"functions/networkfunctions.R\")\nsource(\"functions/custom_functions.R\")"
  },
  {
    "objectID": "session5.html#indlæs-data",
    "href": "session5.html#indlæs-data",
    "title": "Analyse af strategiske netværksroller",
    "section": "Indlæs data",
    "text": "Indlæs data\n\n\nNew names:\n• `` -&gt; `...1`\n\n\nWarning: Unknown or uninitialised column: `assets`.\n\n\nOrbis variable names updated: \n\nDMFull name                                       =&gt; name\nDMUCI (Unique Contact Identifier)                 =&gt; person_id\nDMGender                                          =&gt; person_gender\nDMCountry                                         =&gt; person_country\nDMCountry/ies of nationality                      =&gt; person_countries\nCompany name Latin alphabet                       =&gt; affiliation\nCountry ISO code                                  =&gt; affiliation_country\nDMJob title (in English)                          =&gt; role\nDMBoard, committee or department                  =&gt; board_type\nDMType of role                                    =&gt; role_type\nDMLevel of responsibility                         =&gt; role_level\nDMCurrent or previous                             =&gt; role_status\nNACE Rev. 2, core code (4 digits)                 =&gt; sector\nOperating revenue (Turnover) th USD Last avail. yr=&gt; revenue\nTotal assets th USD Last avail. yr                =&gt; total_assets\nNumber of employees Last avail. yr                =&gt; n_employees\nCSH - BvD ID number                               =&gt; csh_id\nCSH - Name                                        =&gt; csh_name\nCSH - Country ISO code                            =&gt; csh_country\nGUO - BvD ID number                               =&gt; guo_id\nGUO - Name                                        =&gt; guo_name\nGUO - Country ISO code                            =&gt; guo_country\nDUO - BvD ID number                               =&gt; duo_id\nDUO - Name                                        =&gt; duo_name\nDUO - Country ISO code                            =&gt; duo_country\n\n\nNew variables added: \nperson {TRUE/FALSE}\n\n\nFørste blik på data:\n\n\n# A tibble: 6 × 35\n  name       person_id person_gender person_country person_countries affiliation\n  &lt;chr&gt;      &lt;chr&gt;     &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;            &lt;chr&gt;      \n1 Mr Helgel… P3347860… M             Norway         Norway;United S… NOVO NORDI…\n2 Mr Helgel… P3347860… M             Norway         Norway;United S… NOVO NORDI…\n3 Mr Jeppe … P0020235… M             &lt;NA&gt;           Denmark          NOVO NORDI…\n4 Mr Soeren… P8278287… M             Denmark        Denmark          NOVO NORDI…\n5 Mr Soeren… P8278287… M             Denmark        Denmark          NOVO NORDI…\n6 Mr Soeren… P8278287… M             Denmark        Denmark          NOVO NORDI…\n# ℹ 29 more variables: affiliation_country &lt;chr&gt;, role &lt;chr&gt;, board_type &lt;chr&gt;,\n#   role_type &lt;chr&gt;, role_level &lt;chr&gt;, role_status &lt;chr&gt;, sector &lt;chr&gt;,\n#   revenue &lt;dbl&gt;, total_assets &lt;chr&gt;, n_employees &lt;dbl&gt;, csh_id &lt;chr&gt;,\n#   csh_name &lt;chr&gt;, csh_country &lt;chr&gt;, guo_id &lt;chr&gt;, guo_name &lt;chr&gt;,\n#   guo_country &lt;chr&gt;, duo_id &lt;chr&gt;, duo_name &lt;chr&gt;, duo_country &lt;chr&gt;,\n#   Inactive &lt;chr&gt;, Quoted &lt;chr&gt;, Branch &lt;chr&gt;, OwnData &lt;chr&gt;, Woco &lt;chr&gt;,\n#   `Consolidation code` &lt;chr&gt;, `Last avail. year` &lt;chr&gt;, …"
  },
  {
    "objectID": "session5.html#omkodninger",
    "href": "session5.html#omkodninger",
    "title": "Analyse af strategiske netværksroller",
    "section": "Omkodninger",
    "text": "Omkodninger\nVi laver en ny variabel, executive, som er TRUE hvise role_type indeholder enten “BoD” eller “ExeB” eller “SenMan” eller “ExeC” ELLER hvis role indeholder forskellige ord, der indikerer executive level:\n\npharma_nordic &lt;- pharma_nordic %&gt;% mutate(executive = grepl(\"BoD|ExeB|SenMan|ExeC\", role_type) | grepl(\"Director|directeur|Head of|general|Chief|executive|president|Chairman\", role, ignore.case =T))\n\nVi har hentet to forskellige variable på Orbis for personernes geografiske oprindelse: person_country og person_contries. Den første er fødested, den anden er countr(y/ies) of nationality.\nLad os se hvad fødested indeholder:\n\npharma_nordic %&gt;% count(person_country, sort = TRUE)\n\n# A tibble: 38 × 2\n   person_country               n\n   &lt;chr&gt;                    &lt;int&gt;\n 1 &lt;NA&gt;                      5781\n 2 Denmark                    878\n 3 Finland                    349\n 4 Sweden                     349\n 5 Switzerland                281\n 6 Norway                     189\n 7 Germany                    138\n 8 United States of America   125\n 9 Italy                      113\n10 United Kingdom             102\n# ℹ 28 more rows\n\n\nSom I kan se er der mange rækker med NA (missing). Måske kan vi bruge nationalitet til at udfylde nogle rækker:\nLad os se hvad værdien på countries er i de rækker hvor country er NA:\n\npharma_nordic %&gt;% \n  filter(is.na(person_country)) %&gt;%\n  count(person_countries, sort = TRUE) %&gt;% \n  slice_sample(n = 10) # Vi tager 10 tilfældige rækker\n\n# A tibble: 10 × 2\n   person_countries               n\n   &lt;chr&gt;                      &lt;int&gt;\n 1 Sweden;United Kingdom          3\n 2 Iran (Islamic Republic of)    10\n 3 United States;Netherlands      2\n 4 United States;Finland          5\n 5 United Kingdom;Japan;India     2\n 6 Norway;Iceland                 9\n 7 United Kingdom;Denmark         2\n 8 Spain;Sweden                   1\n 9 Ireland;Sweden                 6\n10 Netherlands;Norway             8\n\n\nLad os lave en geografi-variabel person_gep, hvor vi bruger nationalitet når fødested er NA (der, hvor der er flere adskilt af “;”, lad da tage den første) og ellers bruger fødested (.default= person_country):\n\npharma_nordic &lt;- pharma_nordic %&gt;% \n  mutate(person_geo = case_when(is.na(person_country)~\n                                  str_extract(person_countries, \n                                              \"(^.*?(?=;))|(^.*?$)\"),\n                                .default = person_country))\n\nNu har vi færre NA’er:\n\npharma_nordic %&gt;% count(person_geo, sort = TRUE)\n\n# A tibble: 54 × 2\n   person_geo                   n\n   &lt;chr&gt;                    &lt;int&gt;\n 1 &lt;NA&gt;                      2270\n 2 Sweden                    1804\n 3 Denmark                   1214\n 4 Norway                    1007\n 5 Finland                    719\n 6 Switzerland                286\n 7 United Kingdom             226\n 8 Germany                    179\n 9 United States of America   125\n10 United States              116\n# ℹ 44 more rows\n\n\nSom I kan se står der både United States og United States of America, lad os også lige omkode det, så United States bliver til United States of America\n\npharma_nordic &lt;- pharma_nordic %&gt;% \n  mutate(person_geo = case_when(person_geo == \"United States\"~\"United States of America\", .default = person_geo))"
  },
  {
    "objectID": "session5.html#filter",
    "href": "session5.html#filter",
    "title": "Analyse af strategiske netværksroller",
    "section": "Filter",
    "text": "Filter\nSom det sidste trin i data-behandlingen, lad os filtrere så vi kun har rækker, hvor bestyrelsesmedlemmet er en person, hvor rollen er aktiv og hvor vi med vores executive variabel gætter på at det er det højeste ledelsesniveau. Afslutningsvis sørger vi lige for at der ikke er dobbelt roller for samme person i samme virksomhed:\n\npharma_nordic &lt;- pharma_nordic %&gt;% filter(person == TRUE)\npharma_nordic &lt;- pharma_nordic %&gt;% filter(role_status == \"Current\")\npharma_nordic &lt;- pharma_nordic %&gt;% filter(executive == TRUE)\npharma_nordic &lt;- pharma_nordic %&gt;% distinct(name, affiliation, .keep_all = TRUE)"
  },
  {
    "objectID": "session5.html#virksomhedsnetværket",
    "href": "session5.html#virksomhedsnetværket",
    "title": "Analyse af strategiske netværksroller",
    "section": "Virksomhedsnetværket",
    "text": "Virksomhedsnetværket"
  },
  {
    "objectID": "session5.html#individnetværket",
    "href": "session5.html#individnetværket",
    "title": "Analyse af strategiske netværksroller",
    "section": "Individnetværket",
    "text": "Individnetværket"
  },
  {
    "objectID": "session5.html#komponenter",
    "href": "session5.html#komponenter",
    "title": "Analyse af strategiske netværksroller",
    "section": "Komponenter",
    "text": "Komponenter\nmed funktionen count_components finder vi ud af hvor mange sammenhægende komponenter netværkene består af, og med en table på components()$csize kan vi se, hvor mange komponenter af forskellig størrelse der er:\n\n\n\ncount_components(net_virk)\n\n[1] 405\n\ncomponents(net_virk)$csize %&gt;% table()\n\n.\n  1   2   3   4   5   6   7   9  13  63 \n343  32  15   7   1   2   2   1   1   1 \n\n\nVi har altså 343 isolerede virksomheder (komponenter med én virksomhed) og 32 par af virksomheder osv. og en stor komponent på 63 virksomheder\n\n\n\ncount_components(net_ind)\n\n[1] 62\n\ncomponents(net_ind)$csize %&gt;% table()\n\n.\n 1  2  3  4  5  6  7  8 16 77 \n14 17 15  6  3  1  2  2  1  1 \n\n\nVi har altså 14 isolerede individer. og 17 par af individer osv. og en stor komponent på 77 invidider.\n\n\n\nStørste komponenter\nmed largest_component() fra igraph og get_n_largest_component() fra networkfunction.R kan vi ‘udtrække’ hhv. den største og den n’te component fra netværket og gennem dette subnetværk som et selvstændigt objekt:\n\n\n\ncomp1_virk &lt;- largest_component(net_virk)\ncomp2_virk &lt;- get_n_largest_component(net_virk, n = 2)\n\n\n\n\ncomp1_ind &lt;- largest_component(net_ind)\ncomp2_ind &lt;- get_n_largest_component(net_ind, n = 2)"
  },
  {
    "objectID": "session5.html#tilføj-vertex-attributes-der-ikke-er-beregnet-direkte-på-netværksobjektet.",
    "href": "session5.html#tilføj-vertex-attributes-der-ikke-er-beregnet-direkte-på-netværksobjektet.",
    "title": "Analyse af strategiske netværksroller",
    "section": "Tilføj vertex attributes der ikke er beregnet direkte på netværksobjektet.",
    "text": "Tilføj vertex attributes der ikke er beregnet direkte på netværksobjektet.\nSom vi har talt om tidligere kan man ikke udenvidere tilføje vertex attributes fra sit datasæt (er de sorteret ens? er der lige mange rækker osv.?). Jeg har skrevet en lille funktion, som ligger i networkfunctions.R vi har sourcet, og derfor er i vores environment. Funktionen hedder: add_vertex_attr(graph = ., data = ., match_var = .). Den skal have et grafobjekt (som vi gerne vil tilføje variable til), et datasæt (som vi gerne vil tilføje variable fra) og navnet på en match variabel som skal være i datasættet og skal svare til name grafobjektet.\n\n\nfor virksomhedsgrafen kommer V(.)$name jo fra affiliation variablen, så den er match_var her. Lad os sige jeg gerne vil tilføje, country, sector, revenue, assets, employees, global ultimate owner (name + country), domestic ultimate owner (name + country) til det fulde netværk og til mine to komponenter\n\nnet_virk &lt;- add_vertex_attr(graph = net_virk, \n                     data = pharma_nordic %&gt;% \n                            select(affiliation, \n                                   affiliation_country, \n                                   sector, \n                                   revenue,\n                                   total_assets, \n                                   n_employees, \n                                   guo_name, \n                                   guo_country, \n                                   duo_name,\n                                   duo_country),\n                     match_var = \"affiliation\")\n\n\ncomp1_virk &lt;- add_vertex_attr(graph = comp1_virk, \n                     data = pharma_nordic %&gt;% \n                            select(affiliation, \n                                   affiliation_country, \n                                   sector, \n                                   revenue,\n                                   total_assets, \n                                   n_employees, \n                                   guo_name, \n                                   guo_country, \n                                   duo_name,\n                                   duo_country),\n                     match_var = \"affiliation\")\n\n\ncomp2_virk &lt;- add_vertex_attr(graph = comp2_virk, \n                         data = pharma_nordic %&gt;% \n                           select(affiliation, \n                                  affiliation_country, \n                                  sector, \n                                  revenue,\n                                  total_assets, \n                                  n_employees, \n                                  guo_name, \n                                  guo_country, \n                                  duo_name,\n                                  duo_country),\n                         match_var = \"affiliation\")\n\n\n\nfor individgrafen kommer V(.)$name jo fra name variablen, så den er match_var her. Lad os sige jeg gerne vil tilføje køn og geografi for individerne:\n\n\n\n\n\n\nnet_ind &lt;- add_vertex_attr(graph = net_ind, \n                         data = pharma_nordic %&gt;% \n                           select(name, \n                                  person_gender, \n                                  person_geo),\n                         match_var = \"name\")\n\n\n\n\n\n\n\n\ncomp1_ind &lt;- add_vertex_attr(graph = comp1_ind, \n                         data = pharma_nordic %&gt;% \n                           select(name, \n                                  person_gender, \n                                  person_geo),\n                         match_var = \"name\")\n\n\n\n\n\n\n\n\n\ncomp2_ind &lt;- add_vertex_attr(graph = comp2_ind, \n                             data = pharma_nordic %&gt;% \n                               select(name, \n                                      person_gender, \n                                      person_geo),\n                             match_var = \"name\")"
  },
  {
    "objectID": "session5.html#første-graf-plot",
    "href": "session5.html#første-graf-plot",
    "title": "Analyse af strategiske netværksroller",
    "section": "Første graf plot",
    "text": "Første graf plot\nHer fra kører jeg videre med virksomhedsnetværket som eksempel..:\nLad os plotte hele netværket og den største komponent:\nFørst laver vi et plot af hele netværket (net_virk) og gemmer (&lt;-) det i p, og et af den største komponent (comp1_virk) og gemmer (&lt;-) det i p1. Når patchwork pakken er indlæst kan man ‘sætte’ plots sammen med + hvis de skal være ved siden af hinanden eller / hvis de skal være over hinanden:\n\np &lt;- net_virk %&gt;% ggraph(\"fr\") +\n  geom_edge_link0(width = 0.3, alpha = 0.3) +\n  geom_node_point(size = .5) + ggtitle(paste0(\"Netværket i den skandinaviske \\npharmasektor (n=\", vcount(net_virk), \")\")) +\n  theme_graph(base_family = \"serif\")\n\np1 &lt;- comp1_virk %&gt;% ggraph(\"fr\") +\n  geom_edge_link0(width = 0.3, alpha = 0.3) +\n  geom_node_point(aes(color = affiliation_country), size = 1.2) + ggtitle(paste0(\"Største komponent (n=\", vcount(comp1_virk), \")\")) + guides(color = guide_legend(\"Country\")) +\n  theme_graph(base_family = \"serif\")\n\n\np + p1"
  },
  {
    "objectID": "session5.html#egonetværk-af-nabolag.",
    "href": "session5.html#egonetværk-af-nabolag.",
    "title": "Analyse af strategiske netværksroller",
    "section": "Egonetværk af nabolag.",
    "text": "Egonetværk af nabolag.\nI stedet for at se på noden fra netværkets perspektiv, kan vi så at sige vende kikkerten og studere netværket ud fra noden. Et ego netværk er den konfiguration, der udspændes af en enkelt nodes direkte forbindelser og disses relation til hinanden. Hvis vi yderligere tager forbindelsernes forbindelser i betragtning, siger vi at et er ego’s 2nd neigbourhood osv. osv.\nLad os tegne et egonetværk for en enkelt virksomhed. make_ego_graph gør netop dette. Men bemærk at den returnere en liste af netværk, fordi man kan give den flere nodes =, så den laver et ego netværk for hver. Hvis vi kun vælger én node, får vi stadig en liste. Derfor er vi nødt til at skrive [[1]] bagefter for at få element 1 ud af listen.\n\nego &lt;- make_ego_graph(comp1_virk, order = 1, nodes = \"EXOCURE SWEDEN AB\")[[1]]\n\nggraph(ego) +\n  geom_edge_link0() +\n  geom_node_point(size = 2) +\n  geom_node_label(aes(filter = {name == \"EXOCURE SWEDEN AB\"}, label = name)) +\n  theme_graph()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nLad os tage en virksomhed og udvide netværket til 2., 3. og 4. nabolag. På den måde får vi et billede af det større netværk, men set fra denne virksomheds perspektiv.\n\nego &lt;- \"PILA PHARMA AB\"\n# Hvad er et ego netværk\n\npl &lt;- ego_neighborhoods(comp1_virk, 4, ego, labels = FALSE)\n\nggpubr::ggarrange(plotlist = pl, labels = c(\"1st neighbourhood\", \"2nd neighbourhood\", \"3rd neighbourhood\", \"4th neighbourhood\"))\n\n\n\n\n\n\n\n\nVi har talt om trekantslukninger (når A og B og B og C er venner, er der sandsynlighed for at A og C også med tiden bliver det) og om hvordan det skaber closure i et netværk og bidrager til lokal densitet og cohesion - som skaber grundlag for tillid, sammenhold, norm-konformitet osv. Social kapital som gruppe fænomen.\nLad os begynde med at se på hvordan lokal transitivitet ser ud. For hver node i vores netværk kan vi se hvor mange af dens forbindelser der er lukkede (to venner der også kender hinanden) og hvor mange der er åbne (åbne/lukkede kalder vi transitivitet). Lad os tage 12 tilfældige noder (sample() på 12 fra vertex navne) og sortere dem, så den med højest transitivitet kommer først. Bemærk at transitivity() returnerer NaN - not a number - når en node ikke er en del af nogen triplets (så er der hverken faktisk lukkede eller mulige lukkede trekanter at regne på). Hvis vi gerne vil sortere er vi nødt til at erstatte NaN med NA.\n\nrandom_nodes &lt;- sample(V(comp1_virk)$name, 12)\n\nrandom_nodes &lt;- transitivity(comp1_virk, type = \"local\", vids = random_nodes)\nrandom_nodes[is.nan(random_nodes)] &lt;- NA\n\nrandom_nodes &lt;- sort(random_nodes, decreasing = T, na.last = T)\nrandom_nodes &lt;- names(random_nodes)\n\npl &lt;- ego_net_plot(graph = comp1_virk, nodes = random_nodes, mode = \"transitivity\")\n\nLoading required package: tidygraph\n\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\np &lt;- ggpubr::ggarrange(plotlist = pl)\np\n\n\n\n\n\n\n\nggsave(plot = p, filename = \"output/network closure.pdf\", height = 6, width = 10)\n\nMed closure følger imidlertid også muligheden for det R. Burt kalder strukturelle huller mellem ellers tætforbundne grupper. Det giver plads til en særlig netværks rolle, nemlig den at have ikke-redundente forbindelser. Altså forbindelser der rækker ud over den lukkede og dermed tæt forbundne gruppe man er en del af - og dermed få adgang til ny viden fx. Social kapital som brobygning."
  },
  {
    "objectID": "session5.html#assortativity-for-kontinuerte-variable",
    "href": "session5.html#assortativity-for-kontinuerte-variable",
    "title": "Analyse af strategiske netværksroller",
    "section": "Assortativity for kontinuerte variable",
    "text": "Assortativity for kontinuerte variable\nFunktion assortativity() bruges til at beregne assortativity for kontinuerte variable:\nVi kan fx beregne assortativity for degree. Altså, tenderer velforbundne noder mod at være forbundne. “Populær tiltrækker populær”.\n\nassortativity(comp1_virk, values = degree(comp1_virk))\n\n[1] -0.01553398\n\nassortativity_degree(comp1_virk)\n\n[1] -0.01553398\n\n\nDet ser ikke umiddelbart sådan ud. Med en værdi på nærmest 0 ser det ikke ud til at degree tiltrækker degree mere end det ikke gør.\nI mange tilfælde vil det være interessant at beregne assortativity på netværks-eksterne egenskaber. Vi kunne fx. tage antal ansatte, omsætning og assets: er store virksomheder tilbøjelige til at skabe forbindelser til andre store virksomheder:\nførst sætter vi lige missing (NA) til 0 på antal ansatte, omsætning og assets:\n\nV(comp1_virk)$n_employees[is.na(V(comp1_virk)$n_employees)] &lt;- 0\nV(comp1_virk)$revenue[is.na(V(comp1_virk)$revenue)] &lt;- 0\nV(comp1_virk)$total_assets[is.na(V(comp1_virk)$total_assets)] &lt;- 0\n\n\nassortativity(comp1_virk, values = V(comp1_virk)$n_employees)\n\n[1] -0.01537136\n\nassortativity(comp1_virk, values = V(comp1_virk)$revenue)\n\n[1] -0.01108428\n\nassortativity(comp1_virk, values = V(comp1_virk)$total_assets)\n\nWarning in assortativity_impl(graph, values, values.in, directed, normalized):\nNAs introduced by coercion\n\n\n[1] NA\n\n\nHeller ikke den store ‘effekt’ her."
  },
  {
    "objectID": "session5.html#assortativity-for-kategorielle-variable",
    "href": "session5.html#assortativity-for-kategorielle-variable",
    "title": "Analyse af strategiske netværksroller",
    "section": "Assortativity for kategorielle variable",
    "text": "Assortativity for kategorielle variable\nfunktionen assortativity_nominal() bruges til at beregne netværksassortativity for kategorielle variable\nVi gemte fx virksomhedens nationalitet som en vertex attribute, lad os se om det betyder noget: Her skal man lige huske at variablen skal behandles som en factor for at funktionen virker.\n\nassortativity_nominal(comp1_virk, types = factor(V(comp1_virk)$affiliation_country))\n\n[1] 0.3333333\n\n\nIkke så overraskende er der en høj assortativity her. Hvis I scroller op, kan i måske huske at den største komponent i høj grad var en komponent af svenske virksomheder.\nEn anden kategoriel variable kunne være Global Ultimate Owner (guo): Selskaber der ikke er en del af en koncern har NA på guo_name variablen, der sætter vi virksomhedens eget navn ind i stedet:\n\nV(comp1_virk)$guo_name[is.na(V(comp1_virk)$guo_name)] &lt;- V(comp1_virk)$name[is.na(V(comp1_virk)$guo_name)]\n\n\nassortativity_nominal(comp1_virk, types = factor(V(comp1_virk)$guo_name))\n\n[1] 0.1660473"
  },
  {
    "objectID": "session4.html",
    "href": "session4.html",
    "title": "Centralitetsanalyse",
    "section": "",
    "text": "I denne session skal vi se på hvad centralitet betyder i en netværkssammenhæng.\n“in the thick of things”\nLad os installere en ny pakke, hvis ikke den allerede er installeret. Den skal vi bruge senere til at lave pæne opsætninger af vores visualiseringer. Det er ggpubr-pakken, som blandt andet gør det muligt at sætte plotssammen.\n# install.packages(\"ggpubr\")\nLad os dernæst indlæse de pakker vi skal bruge\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(igraph)\nlibrary(ggraph)\nlibrary(Matrix)"
  },
  {
    "objectID": "session4.html#afstande-kilometer-distinktion-eller-stilængder",
    "href": "session4.html#afstande-kilometer-distinktion-eller-stilængder",
    "title": "Centralitetsanalyse",
    "section": "Afstande, kilometer, distinktion eller stilængder",
    "text": "Afstande, kilometer, distinktion eller stilængder\nVi er vant til at tænke afstand på forskellige måder. Åbenlyst opmåler vi hele tiden den fysiske verden i meter og km, mv. Hvor langt er der på arbejder? I kender formentlig også til den franske sociolog Pierre Bourdieus repræsentation af samfundet som et to-dimensionelt rum. En slags formalisering af noget I også er vant til at tale om og føle, nemlig at vi i hverdagen oplever sociale afstande; direktøren vs professoren vs fabriksarbejderen osv. I netværk har vi også et begreb om afstande. Her tænker vi i stier. Afstanden fra en vertice i et netværk til en anden et det mindste antal af edges vi skal passere igennem for at komme fra den ene til den anden. Selvom netværksvisualiseringen (nedenfor til venstre) placerer A og B visuelt tæt på hinanden er netværksafstanden (den korteste sti) fra A til B seks, mens den korteste sti mellem A og C, der visuelt ligger længere fra hinanden er fem. Det er tre forskellige måder at tænke afstande på (omend de ofte er relateret - men det er en anden historie).\n\nI en forbundet graf (hvor der er en eller flere stier fra alle vertices til alle andre vertices) har alle vertices en defineret afstand til hinanden, nemlig den korteste sti (shortest path eller geodesic path). Når vi har et begreb om afstand i netværk (geodesic distance) kan vi begynder at måle forskellige ting, bl.a. centalitet."
  },
  {
    "objectID": "session4.html#centralitet-generelt",
    "href": "session4.html#centralitet-generelt",
    "title": "Centralitetsanalyse",
    "section": "Centralitet generelt",
    "text": "Centralitet generelt\nI det følgende skal kigge på en række forskellige måder at konceptualisere centralitet i netværk på. De bygger på forskellige ideer og intuitioner, men har det til fælles at det er måder at undersøge spørgsmålene: Hvem har strukturelt vigtige positioner i et netværk?\nLinton C Freeman (1979) påpeger at det idealtypiske billede på centralitet er en såkaldt stjernegraf, hvor en node er forbundet til alle andre, der hver især kun er forbundet til denne:\n\nstar &lt;- make_star(10, mode = \"undirected\")\nV(star)$name &lt;- LETTERS[1:10]\nstar %&gt;% ggraph(\"kk\") +\n  geom_edge_link0() +\n  geom_node_label(aes(label = name, size = degree(star)), show.legend = F) +\n  scale_size_continuous(range = c(3,6)) +\n  theme_graph(base_family = \"serif\") + labs(title = \"Stjernegraf med 10 noder\", caption = \"Freeman, Linton C. 1979. “Centrality  in Social Networks  Conceptual  Clarification.” Social  Networks 1979(1):215–39.\")\n\n\n\n\n\n\n\n\nI denne situation er A den mest centrale node, fordi den har flest ‘kontakter’, 9 i alt, hvor de øvrige kun har 1. A’s centralitet kan også udtrykkes i termer af afstande, A er så at sige tættest på de andre node, da A i et led kan nå alle, mens alle andre har skal gå to led for at nå andre end A. Det betyder videre at A også er mest central i den forstand at al ‘kommunikation’ mellem de andre noder nødvendigvis må gå gennem A. Med andre ord: A er den mest populære i ‘klassen’, A har også lettest ved at sprede et budskab (et rygte måske? eller en virus?) og A har også lettest adgang til viden (sladder måske?) da en information for at komme fra B til nogen anden aktør må gå gennem A."
  },
  {
    "objectID": "session4.html#degree-centralitet",
    "href": "session4.html#degree-centralitet",
    "title": "Centralitetsanalyse",
    "section": "Degree centralitet:",
    "text": "Degree centralitet:\nIde: centralitet kommer til udtryk i høj “aktivitet”, en central aktør er en aktør med mange direkte kontakter.\nPraksis: Tæller hvor mange direkte forbindelser hver node har, dvs hvor mange andre noder den er forbundet til.\n\nI et ikke-retningsbestemte netværk (undirected) der kun et degree mål.\nI retningsbestemte netværk har hver node en:\n\n‘out degree’ (udadgående forbindelser)\n‘in degree’ (indkommende forbindelser)\nTotal degree (summen af de to).\n\n\nLad os udregne degree (med degree() funktionen fra igraph) for noderne i den største komponent:\nBeslutning: Hvis netværket er retningsbestemt skal det defineres i funktionen om det er in, out eller total degree vi vil udregne (fx degree(...mode = \"in\") eller degree(...mode = \"out\" etc.))\n\ndeg &lt;- degree(largest_comp_virk) \ntable(deg)\n\ndeg\n  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 \n105 100  90  77  54  47  40  35  35  21  17  26  16  17  24  16  13   9   5   7 \n 21  23  24  25  26  28  30 \n  5   1   3   3   4   2   1 \n\n\nfordi degree er udregnet på grafobjektet (og derfor er sorteret på samme måde), kan vi uden problemer tilføje vores degree variable som en ny vertex attribute. Det kan vi gøre på to måder: 1) med V(netværksobjekt)$\"nyt attribute\" &lt;- degree 2) med en funktion set_vertex_attr()\n\n#1)\nV(largest_comp_virk)$degree &lt;- deg\n#2)\nlargest_comp_virk &lt;- set_vertex_attr(largest_comp_virk, name = \"degree\", value = deg)\n\nLad os undersøge hvordan degree fordelingen ser ud (med et histogram) og hvordan degree fordelingen beskriver netværket (med et grafplot):\n\nhist_deg &lt;- deg %&gt;% tibble() %&gt;% \n  ggplot() +\n  geom_histogram(aes(x=.), fill = \"grey20\") + #binwidth definerer, hvor mange kategorier på x-aksen en søje i histogrammet skal 'opsummere'\nscale_y_continuous(breaks = seq(0,100, 10), name = \"Antal\") + scale_x_continuous(breaks = c(1, seq(5,max(deg), 5)), minor_breaks = seq(0,max(deg), 1), name =\"Degree\") + theme_minimal(base_family = \"serif\")\n\np_deg &lt;- largest_comp_virk %&gt;% \n  ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.45) + \n  geom_node_point(aes(color=degree), alpha=0.8)  + \n  labs(title = paste0(\"Den største komponent (n=\", vcount(largest_comp_virk),\")\"), subtitle = \"degree\", color = \"\") +\n  theme_graph() + theme(plot.title = element_text(family = \"serif\", size = 12), plot.subtitle = element_text(family = \"serif\", size = 12), legend.position = \"bottom\")\n\nggarrange(plotlist = list(hist_deg, p_deg), widths = c(1.4,2))"
  },
  {
    "objectID": "session4.html#eigenvector-centrality",
    "href": "session4.html#eigenvector-centrality",
    "title": "Centralitetsanalyse",
    "section": "Eigenvector centrality:",
    "text": "Eigenvector centrality:\nIde: som med degree, det er godt at have mange ‘venner’, men det er endnu bedre, hvis disse venner også er populære!\nPraksis: Udregnes hurtigt med ‘kompliceret’ matematik, eigenvector decomposition, deraf navnet. Intuitionen i målet er: Alle noder starter med en ‘vægt’ på 1, for hver node tælles summen af deres forbindelsers ‘vægt’, svarer i første omgang til degree, gentages i flere runder, hvorved noder der er forbundne til velforbundne node, stiger hurtigere (= er mere centrale), skaleres til at være mellem 0 og 1, hvor 0 er isolates og 1, den mest centrale.\nBeslutninger: 1) skal edgevægte betyder noget? Hvis vi ikke skriver noget tager den edgeweights med, hvis der er nogen, hvis vi skriver weights = NA tager udregningen ikke hensyn til edgeweights, dvs. alle forbindelser har samme vægt (w=1). 2) er netværket retningsbestemt?\nProblemer: Værk opmærksom. Hvis vi har et netværk med en meget ‘skæv’ fordeling af degree, vil der ske det at få meget velforbundne noder, ‘hubs’, vil ‘skabe’ en lokaliseringseffekt på eigevector centralitetn, således at den mest indfanger forskellen på dette hub og resten af netværket. Fordi eigencentraliteten udregnes i skridt, hvor en nodes centralitet afhænger af dens ‘naboer’ centralitet. I næste runde vil en nodes egen centralitet så at sige blive reflekteret tilbage i kraft af dens naboer (som jo nu har ‘lånt’ dennes osv.) - et feedback loop, der kan skabe en situation hvor al centralitet samles omkring et hub og centraliteten for resten af netværket går mod 0. Er det en korrekt beskrivelse af centraliteten af forskellige aktører?\n\neig &lt;- eigen_centrality(largest_comp_virk, weights = NA, directed = FALSE)\nstr(eig)\n\nList of 3\n $ vector : Named num [1:773] 0.00272 0.00445 0.0023 0.012 0.48501 ...\n  ..- attr(*, \"names\")= chr [1:773] \"3C Groups\" \"3xN\" \"5E Byg (Bestyrelse)\" \"7N\" ...\n $ value  : num 14.8\n $ options:List of 20\n  ..$ bmat   : chr \"I\"\n  ..$ n      : int 773\n  ..$ which  : chr \"LA\"\n  ..$ nev    : int 1\n  ..$ tol    : num 0\n  ..$ ncv    : int 0\n  ..$ ldv    : int 0\n  ..$ ishift : int 1\n  ..$ maxiter: int 3000\n  ..$ nb     : int 1\n  ..$ mode   : int 1\n  ..$ start  : int 1\n  ..$ sigma  : num 0\n  ..$ sigmai : num 0\n  ..$ info   : int 0\n  ..$ iter   : int 4\n  ..$ nconv  : int 1\n  ..$ numop  : int 50\n  ..$ numopb : int 0\n  ..$ numreo : int 40\n\neig &lt;- eig$vector\n\nlad os igen gemme eigencentraliteten som en vertex attribute\n\nV(largest_comp_virk)$eigencentrality &lt;- eig\n\nog plotte fordelingen og netværket\n\nhist_eig &lt;- eig %&gt;% tibble() %&gt;% \n  ggplot() +\n  geom_histogram(aes(x=.), fill = \"grey20\") +\n  scale_y_continuous(name = \"Antal\") + scale_x_continuous(breaks = seq(0,max(eig), .1), name =\"Eigencentralitet\") +\n  theme_minimal(base_family = \"serif\")\n\np_eig &lt;- largest_comp_virk %&gt;% \n  ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.45) + \n  geom_node_point(aes(color=eigencentrality), alpha=0.8)  + \n  labs(title = paste0(\"Den største komponent (n=\", vcount(largest_comp_virk),\")\"), subtitle = \"Eigencentrality\", color = \"\") +\n  theme_graph() + theme(plot.title = element_text(family = \"serif\", size = 12), plot.subtitle = element_text(family = \"serif\", size = 12), legend.position = \"bottom\")\n\nggarrange(plotlist = list(hist_eig, p_eig), widths = c(1.4,2))"
  },
  {
    "objectID": "session4.html#excentricitets-centralitet",
    "href": "session4.html#excentricitets-centralitet",
    "title": "Centralitetsanalyse",
    "section": "Excentricitets centralitet:",
    "text": "Excentricitets centralitet:\nIde: Et netværk har yderpunkter, dvs. noder der er længst fra hinanden. De siges at ligge i periferien og deres afstand er derfor netværkets diameter. Den/de noder der har den korteste afstand deres fjerneste node, kalder vi centrum i netværket, og afstanden til periferien, radius.\nPraksis: En nodes eccentricitet er deres maksimale afstand (korteste sti) til en anden node.\n\nDet er almindeligt at bruge den inverse eccentricitet (dvs \\(1 \\over eccentricity\\)) som centralitetsmål, så perifære noder får et lavere tal og centrale noder et højre.\n\necc &lt;- 1 / eccentricity(largest_comp_virk, weights = NA)\n\nlad os igen gemme eccentricity centraliteten som en vertex attribute i vores grafobjekt:\n\nV(largest_comp_virk)$eccentricity &lt;- ecc\n\nog kigge på fordelingen og netværket\n\nhist_ecc &lt;- ecc %&gt;% tibble() %&gt;% \n  ggplot() +\n  geom_histogram(aes(x=.), fill = \"grey20\") +\n  scale_y_continuous(name = \"Antal\") + scale_x_continuous(breaks = seq(0,max(ecc), .01), name =\"1/Eccentricity\") +\n  theme_minimal(base_family = \"serif\")\n\np_ecc &lt;- largest_comp_virk %&gt;% \n  ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.45) + \n  geom_node_point(aes(color=eccentricity), alpha=0.8)  + \n  labs(title = paste0(\"Den største komponent (n=\", vcount(largest_comp_virk),\")\"), subtitle = \"1/Eccentricity\", color = \"\") +\n  theme_graph() + theme(plot.title = element_text(family = \"serif\", size = 12), plot.subtitle = element_text(family = \"serif\", size = 12), legend.position = \"bottom\")\n\nggarrange(plotlist = list(hist_ecc, p_ecc), widths = c(1.4,2))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."
  },
  {
    "objectID": "session4.html#closeness-centralitet",
    "href": "session4.html#closeness-centralitet",
    "title": "Centralitetsanalyse",
    "section": "Closeness centralitet:",
    "text": "Closeness centralitet:\nIde: en central netværks-aktør er en der (i gennemsnit) er tæt på de andre i netværket. En der hurtigt kan række ud i netværket og derfor har en grad af uafhængighed. Hvor eccentricitet måler hvor langt der er til den fjerneste nabo, måler closeness i stedet hvor langt der i gennemsnit er til alle naboer.\nI praksis: udregnes (for node A) som: summen af A’s netværksafstand (shortest path) til alle andre noder / antallet af noder (udover A selv). Det svarer til den gennemsnitlige afstand til netværkets andre aktører. Almindeligvis bruges den inverse gennemsnitsafstand som centralitetsmål (det er også det mål igraph producerer), så et lavt tal betyder lav centralitet og et højt tal en ‘højere’ centralitet.\n\nclo  &lt;- closeness(largest_comp_virk, weights = NA) \n\nIgen, lad os gemme closeness centraliteten i vores grafobjekt som en vertex attribute:\n\nV(largest_comp_virk)$closeness &lt;- clo\n\nog producere det samme overblik over fordelingen og netværket:\n\nhist_clo &lt;- clo %&gt;% tibble() %&gt;% \n  ggplot() +\n  geom_histogram(aes(x=.), fill = \"grey20\") +\n  scale_y_continuous(name = \"Antal\") + scale_x_continuous(name =\"Closeness\") + theme_minimal(base_family = \"serif\")\n\np_clo &lt;- largest_comp_virk %&gt;% \n  ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.45) + \n  geom_node_point(aes(color=closeness), alpha=0.8)  + \n  labs(title = paste0(\"Den største komponent (n=\", vcount(largest_comp_virk),\")\"), subtitle = \"Closeness\", color = \"\") +\n  theme_graph() + theme(plot.title = element_text(family = \"serif\", size = 12), plot.subtitle = element_text(family = \"serif\", size = 12), legend.position = \"bottom\")\n\nggarrange(plotlist = list(hist_clo, p_clo), widths = c(1.4,2))\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`."
  },
  {
    "objectID": "session4.html#betweenness-centralitet",
    "href": "session4.html#betweenness-centralitet",
    "title": "Centralitetsanalyse",
    "section": "Betweenness centralitet:",
    "text": "Betweenness centralitet:\nHvis vi i stedet for at kigge på afstanden til alle andre, kigger på hvor hyppigt en aktør ligger på den korteste sti mellem andre noder, så får vi et bud på hvor nødvig en given aktør er for at ‘noget’ (kommunikation/sladder/viden etc.) kan flyde mellem de andre aktører\nIde: En central node er en der er uundværlig for at andre noder, der ikke er direkte forbundne, kan ‘nå’ hinanden, dvs. én der bygger bro, én gatekeeper osv.\nI praksis (for en given node, A): tæller antallet af korteste stier, parvist, mellem alle andre noder, der går igennem A.\n\nbet &lt;- betweenness(largest_comp_virk, weights = NA) \n\n\nV(largest_comp_virk)$betweenness &lt;- bet\n\n\nhist_bet &lt;- bet %&gt;% tibble() %&gt;% \n  ggplot() +\n  geom_histogram(aes(x=.), fill = \"grey20\") + \n  scale_y_continuous(name = \"Antal\") + scale_x_continuous(name =\"Betweenness\") + theme_minimal(base_family = \"serif\")\n\np_bet &lt;- largest_comp_virk %&gt;% \n  ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.45) + \n  geom_node_point(aes(color=betweenness), alpha=0.8)  + \n  labs(title = paste0(\"Den største komponent (n=\", vcount(largest_comp_virk),\")\"), subtitle = \"Betweenness\", color = \"\") +\n  theme_graph() + theme(plot.title = element_text(family = \"serif\", size = 12), plot.subtitle = element_text(family = \"serif\", size = 12), legend.position = \"bottom\")\n\nggarrange(plotlist = list(hist_bet, p_bet), widths = c(1.4,2))"
  },
  {
    "objectID": "session4.html#centralitetsrank",
    "href": "session4.html#centralitetsrank",
    "title": "Centralitetsanalyse",
    "section": "Centralitetsrank",
    "text": "Centralitetsrank\nDet kan være en god ide at lave en rankvariabel for de forskellige mål, som ranker alle noder efter deres centralitet på de forskellige mål. Funktionen dense_rank() kombineret med desc() (descending) giver os et rank hvor noden med den højeste centralitet bliver nr 1 og de andre noder, 2,3,4,5 osv. jo lavere deres centralitet er. Det gør det lidt lettere at overskue, hvor en bestemt node er placeret på de forskellige centralitetsmål.\nNår vi skriver i stedet for at skrive koden for hver eneste centralitets mål kan vi bruge funktionen across() inde i mutate() det betyder at vi i denne sammen hæng gør ‘noget’ henover alle kolonner undtagen name .cols = -name, det vi gør er en funktion .fns = som er (~ betyder her funktion) dense_rank(desc(.x)) (hvor .x betyder elmeneterne i .cols, altså for hver af kolonnerne der ikke er name), det sidste udtryk vi skriver i across funktionen er hvad der skal ske med variablene. Hvis vi ikke skriver noget her, overskriver vi de gamle variable. Hvis vi som nedenfor skriver .names = \"{.col}_rnk\" betyder det at vi laver nye variable der kommer til at hedde det samme som de gamle \"{.col}\" + _rnk. Dvs. rangeringen af degree bliver til ny variabel degree_rnk.\n\ncent_metrics_rnk &lt;- cent_metrics %&gt;% mutate(across(.cols = -name, .fns = ~dense_rank(desc(.x)), .names = \"{.col}_rnk\"))"
  },
  {
    "objectID": "session4.html#måler-de-forskellige-centralitetsmål-i-realiteten-noget-forskelligt",
    "href": "session4.html#måler-de-forskellige-centralitetsmål-i-realiteten-noget-forskelligt",
    "title": "Centralitetsanalyse",
    "section": "Måler de forskellige centralitetsmål i realiteten noget forskelligt?",
    "text": "Måler de forskellige centralitetsmål i realiteten noget forskelligt?\nJeg har skrevet en plot-funktion der ligger i networkfunctions.R som kan downloads her:\nDownload functions\neller hentes på kursets hjemmeside.\nHvis I lægger den i functionsmappen i rprojekt-mappen, kan i source den som med andre scripts:\n\nsource(\"functions/networkfunctions.R\", echo = FALSE)\n\nmed cor_plots() funktionen kan vi lave et hurtigt plot, der viser korrelationen mellem de f orskellige centralitetsmål:\nVi kan lige normalisere alle målene, så de går fra 0 til 1 det gør vi ved at dividere alle med max (for dem der allerede er normaliseret betyder det ingen ting da x/1 jo er x). Undtagen selvfølgelig name variablen (så den skipper vi i across funktionen across(.cols = -name, ...))\n\ncent_metrics_norm &lt;- cent_metrics %&gt;% mutate(across(.cols = -name, .fns = ~.x / max(.x))) \n\nI cor_plots() skal I huske at skrive hvilken variabel i jeres dataobjekt, der er en navne-variabel (som default leder den efter “name” eller “affiliation”). Der er også mulighed for at sætte en plot.title, (default er “Korrelationer mellem centralitetsmål”) og en title.size (default er 12):\n\ncent_metrics_norm %&gt;% cor_plots(., name_var = \"name\")\n\n\n\n\n\n\n\n\nog vi kan se de parvise correlationer mellem målenen (vi ‘smider’ igen name-variablen ud select(-name))\n\ncent_metrics_norm  %&gt;% select(-name) %&gt;% cor(, method = \"kendall\")\n\n                   degree eigencentrality eccentricity closeness betweenness\ndegree          1.0000000       0.5928250    0.4545670 0.6668908   0.6239287\neigencentrality 0.5928250       1.0000000    0.3014166 0.7061808   0.3941713\neccentricity    0.4545670       0.3014166    1.0000000 0.5468315   0.4254326\ncloseness       0.6668908       0.7061808    0.5468315 1.0000000   0.5194376\nbetweenness     0.6239287       0.3941713    0.4254326 0.5194376   1.0000000\n\n\nKonklussion: De er allesammen korrelerede til hinanden i forskellige grad, men slet ikke perfekt, da de udtrykker forskellige aspekter af hvad det vil sige at være central i et netværk:\n Fig fra: fra: Ortiz-Arroyo, Daniel. 2010. “Discovering Sets of Key Players in Social Networks.” pp. 27–47 in Computational Social Network Analysis, Computer Communications and Networks, edited by A. Abraham, A.-E. Hassanien, and V. Snásel. London: Springer London.\nDegree: ‘simpel’ popularitet, dvs. hvem har flest forbindelser. Closeness: effektiv spreder af information, da høj closeness betyder at resten af netværket er relativt tilgængeligt for denne node. Betweennes: kontrol med information, høj betweenness betyder at en stor del af det, der ‘flyder’ mellem noder i netværket går gennem denne node.\nJo mere et netværk ‘ligner’ en stjernegraf eller dvs. jo mere kerne-periferi agtig netværksstrukturen er desto mere vil de forskellige centralitetsmål korrelere. Fordi de måler den samme underliggende kerneperiferistruktur."
  },
  {
    "objectID": "session4.html#coreness-eller-k-core-decomposition",
    "href": "session4.html#coreness-eller-k-core-decomposition",
    "title": "Centralitetsanalyse",
    "section": "Coreness eller K-core decomposition",
    "text": "Coreness eller K-core decomposition\nEn anden måde at tænke centralitet på, med udgangspunkt i netværkets kerne/periferi struktur\nide: Første lag K=0: Alle noder; Andet lag K=1 alle noder med &lt; 1 forbindelse slettes; næste lag K=2 alle noder der nu har &lt;2 forbindelser slettes; K=3 alle noder der nu har &lt;3 forbindelser slettes osv. indtil man ikke kan slette noder uden at antallet af de reterende noders forbindelser falder….\n\ncore &lt;- coreness(largest_comp_virk) \ntable(core)\n\ncore\n  1   2   3   4   5   6   7   8   9  11 \n124 122 126  97  81  71  53  27  57  15 \n\n\nLad os prøve at visualisere logikken med en funktion fra networkfunctions.R\n\ncoreness_viz(largest_comp_virk, algorithm = 'kk') \n\n\n\n\n\n\n\n\nlad os lige tilføje coreness til vores cent_metrics data og til grafobjektet\n\ncent_metrics &lt;- cent_metrics %&gt;% mutate(coreness = core)\nV(largest_comp_virk)$coreness &lt;- core"
  },
  {
    "objectID": "session4.html#visualisering-af-eccentriciteten",
    "href": "session4.html#visualisering-af-eccentriciteten",
    "title": "Centralitetsanalyse",
    "section": "Visualisering af eccentriciteten",
    "text": "Visualisering af eccentriciteten\n\nlargest_comp_virk %&gt;% ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.35) +\n  geom_node_point(aes(color=eccentricity, size = eccentricity, alpha = eccentricity), show.legend = F) + \n  theme_graph() + scale_color_viridis(direction = -1) + labs(color=\"1/Eccentricity\") +\n  geom_node_label(aes( filter=name %in% {cent_metrics %&gt;% filter(eccentricity %in% c(min(eccentricity), max(eccentricity))) %&gt;% pull(name)}, label=name), alpha=0.65, size = 3, repel=T, force = 10)"
  },
  {
    "objectID": "session4.html#visualisering-af-betweenness",
    "href": "session4.html#visualisering-af-betweenness",
    "title": "Centralitetsanalyse",
    "section": "Visualisering af betweenness",
    "text": "Visualisering af betweenness\n\nlargest_comp_virk %&gt;% ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.35) + \n  geom_node_point(aes(color=betweenness, size = betweenness, alpha = betweenness), show.legend = F) + \n  theme_graph() + scale_color_viridis(direction = -1) + labs(color=\"Betweenness\") + \n  geom_node_label(aes( filter=name %in% {cent_metrics_rnk %&gt;% filter(betweenness_rnk &lt;= 10) %&gt;% pull(name)}, label=name), alpha=0.65, size = 3, repel=T, force = 20)"
  },
  {
    "objectID": "session4.html#visualisering-af-closeness",
    "href": "session4.html#visualisering-af-closeness",
    "title": "Centralitetsanalyse",
    "section": "Visualisering af closeness",
    "text": "Visualisering af closeness\n\nlargest_comp_virk %&gt;% ggraph(layout='stress') + \n  geom_edge_link0(color='grey', width=0.6, alpha=0.35) +\n  geom_node_point(aes(color=closeness, size = closeness, alpha = closeness), show.legend = F) + \n  theme_graph() + scale_color_viridis(direction = -1) + \n  labs(color=\"Closeness\") + \n  geom_node_label(aes( filter=name %in% {cent_metrics_rnk %&gt;% filter(closeness_rnk &lt;= 10) %&gt;% pull(name)}, label=name), alpha=0.65, repel=T,size=3, force = 20)\n\nWarning: ggrepel: 1 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "session3.html",
    "href": "session3.html",
    "title": "Indsamling af netværksdata og konstruktion af netværksobjekter",
    "section": "",
    "text": "Note\n\n\n\nSom med al anden indsamling af samfundsvidenskabelig data er det også med netværksanalyse meget vigtig at man forholder sig til en række metodologiske og videnskabsteoretiske spørgsmål, allerede i den fase, hvor man overvejer hvilken data man vil indsamle(/bruge) og hvordan man vil indsamle(/bruge) det!\n\n\nI social netværksanalyse behandler vi data relationelt, dvs. vi har nogle enheder (mennesker, virksomheder, ‘ideer/begreber’, hjemmesider), som vi antager indgår i nogle relationer, som vi gerne vil strudere på en systematisk måde. Det betyder at vi på et visuelt plan hele tiden arbejder med punkter (vertices eller noder) der er forbundet (eller ikke forbundet) af streger (edges):\n\n\n\n\n\n\n\n\nDet rejser nogle vigtige spørgsmål:\n\nHvad er en relation?\n\nEr det medlemskaber (som i figuren til højre, de to blå punkter er begge medlem af det røde punkt), er det venskaber/kendskaber (som i figuren til venstre de tre blå punkter kender hinanden). Er relationen samtidig? dvs. Er de to blå punkter fx. medlem af den samme klub nu(!) eller er det nok (for vores analyse) at de begge har været med på et tidspunkt, men ikke nødvendigvis samtidig? En forbindelse kan også udtrykke udveklingsrelationer. Er det fx to virksomheder der sender penge eller varer til hinanden? Eller kampagnedonationer til politikere/partier? Relationer kan også være mere abstrakte, fx. relationer mellem ideer og begreber, fx semantiske relationer eller referencer - “forfatter B” trækker på “forfatter A”s ideer osv. På mange måder mulighederne uendelige. Det vigtigste er at man er eksplicit og tydelig omkring hvad man mener man kigger på. Det har nemlig stor betydning for om man faktisk viser det man tror man viser i sine analyser. Det er også afgørende om tænker at relationen har en retning, som i eksemlet med forfatter B, der trækker på forfatter As ideer. Der kan man sige at relationen fra B til A (eller den anden vej for den sags skyld; er det det at B trækker på A, der er afgørende eller er det det at ideen flyder fra A til B der er afgørende?). Eller er relationen gensidig, når A og B er vener. Har relationerne forskellig vægt? Kender A og B fx hinanden mere eller bedre end B kender C osv.?\n\nHvad er et punkt?\n\nI skal også forholde jer til hvad enheden i analyserne er? Hvad er udgør et punkt? Og hvilke punkter skal med? Hvis vi kiggede på venskaber i en klasse, så er punkterne måske klassens elever. Men hvad hvis elev A og B ikke nævner hinanden som venner, men begge nævner X fra parallelklassen? Skal X så med? Skal hele parallelklassen med? Eller hele skolen? Og måske også naboskolen? Det er et helt afgørende spørgsmål i netværksanalyse: Hvor starter og slutter netværket?\n\nHvilken slags netværk er det vi kigger på?\n\nSom vi tidligere har talt om kan vi have både netværk mellem en enkelt type af aktører og netværk mellem flere typer af ‘aktører’. Ofte har vi måske indsamlet et netværk med to distinkte typer (et bipartite netværk), fx bestyrelsespersoner og deres virksomheder, eller forfattere og deres begreber osv. I en analytisk sammenhæng kunne vi måske være interesseret i at rette blikket mod (de formidlede) relationer mellem én netværkets enheder. Det kræver en så kaldt projektion af netværket.\n\n\n\nEn vigtig del af en netværksanalyse er at forholde sig til spørgsmål som disse. Hvilken mekanisme er vi interesseret i at studere. Er vi optaget af en epidemologisk kortlægning af risikoen for spredning af coronavirus? Ja men, så vi nødt til at tænke relationen som en eller anden grad af fysisk kontakt. Er vi interesseret i indflydelse på beslutninger, så er relationen måske medlemskab i organer, hvor der træffes beslutninger. Er vi interesseret i popularitet og anerkendelse, så er relationen vi skal lede efter måske oplevede venskaber. Vil vi studere muligheder for innovation i virksomheder, så skal vi måske forstå relationerne som et flow af vidensdeling mellem individer eller teams.\nSelvom netværksanalyse på papiret ‘bare’ er punkter og streger er det altså utrolig vigtigt at forholde sig til hvad punkterne og stregerne repræsenterer."
  },
  {
    "objectID": "session3.html#danish-elite-network-2017-den17",
    "href": "session3.html#danish-elite-network-2017-den17",
    "title": "Indsamling af netværksdata og konstruktion af netværksobjekter",
    "section": "Danish Elite Network 2017 (den17)",
    "text": "Danish Elite Network 2017 (den17)\nI mappen \"/data\" i R projketet finder i filen den17-no-nordic-letters.csv. Den kan også downloades her:\nDownload den17\nIndlæs data med read_csv\n\nden &lt;- read_csv(\"data/den17-no-nordic-letters.csv\")\n\nden17 er et affiliation datasæt, som indeholder bestyrelsesposter og og andre medlemskaber i (stort set) alle (relevante) virksomheder, organisationer, fonde, insitutioner, råd, nævn, kommissioner osv. Dvs alt lige fra Kattens Vaern over A.P. Moeller - Maersk og Novo Nordisk til regeringens sikkerhedsudvalg osv. Hver række i datasættet repræsenterer en position, dvs. en person med en rolle i organisation:\n\nden %&gt;% head()\n\n# A tibble: 6 × 10\n  name    affiliation role  gender tags  sector type  cvr_person cvr_affiliation\n  &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;           &lt;dbl&gt;\n1 Lars E… & co        Memb… Men    Corp… Corpo… Virk… 4006470500        21705535\n2 Mikael… & co        Exec… Men    Corp… Corpo… Virk… 4004059627        21705535\n3 Thomas… & co        Chai… Men    Corp… Corpo… Virk… 4004304040        21705535\n4 Thomas… & co        Memb… Men    Corp… Corpo… Virk… 4004062718        21705535\n5 Hans J… 15. juni f… Chai… Men    Char… Found… Fond…         NA        15232102\n6 Niels … 15. juni f… Vice… Men    Char… Found… Fond… 4000067364        15232102\n# ℹ 1 more variable: description &lt;chr&gt;\n\n\nVi kan bruge glimpse() til lige at se hvad data ellers indeholder:\n\nden %&gt;% glimpse()\n\nRows: 56,849\nColumns: 10\n$ name            &lt;chr&gt; \"Lars Eivind Kreken\", \"Mikael Ernst Joergensen\", \"Thom…\n$ affiliation     &lt;chr&gt; \"& co\", \"& co\", \"& co\", \"& co\", \"15. juni fonden (Best…\n$ role            &lt;chr&gt; \"Member\", \"Executive\", \"Chairman\", \"Member\", \"Chairman…\n$ gender          &lt;chr&gt; \"Men\", \"Men\", \"Men\", \"Men\", \"Men\", \"Men\", \"Women\", \"Wo…\n$ tags            &lt;chr&gt; \"Corporation, Media, Marketing, Commercials, Communica…\n$ sector          &lt;chr&gt; \"Corporations\", \"Corporations\", \"Corporations\", \"Corpo…\n$ type            &lt;chr&gt; \"Virksomhed (CVR)\", \"Virksomhed (CVR)\", \"Virksomhed (C…\n$ cvr_person      &lt;dbl&gt; 4006470500, 4004059627, 4004304040, 4004062718, NA, 40…\n$ cvr_affiliation &lt;dbl&gt; 21705535, 21705535, 21705535, 21705535, 15232102, 1523…\n$ description     &lt;chr&gt; \"Automatisk CVR import at 2016-03-12 17:45:41: BESTYRE…\n\n\nAlle ‘organisationer’ i datasættet er kodet med en række tags som kategoriserer organisationerne i forskellige emner.\n\nden %&gt;% select(name, affiliation, tags)\n\n# A tibble: 56,849 × 3\n   name                    affiliation                  tags                    \n   &lt;chr&gt;                   &lt;chr&gt;                        &lt;chr&gt;                   \n 1 Lars Eivind Kreken      & co                         Corporation, Media, Mar…\n 2 Mikael Ernst Joergensen & co                         Corporation, Media, Mar…\n 3 Thomas Hoegeboel        & co                         Corporation, Media, Mar…\n 4 Thomas Hoffmann         & co                         Corporation, Media, Mar…\n 5 Hans Joergen Rasmusen   15. juni fonden (Bestyrelse) Charity, Culture, Found…\n 6 Niels Thomas Heering    15. juni fonden (Bestyrelse) Charity, Culture, Found…\n 7 Else Mikkelsen 55281    15. juni fonden (Bestyrelse) Charity, Culture, Found…\n 8 Helene K. Hjenner       15. juni fonden (Bestyrelse) Charity, Culture, Found…\n 9 Jette Baagoee           15. juni fonden (Bestyrelse) Charity, Culture, Found…\n10 Zeb Meier Watz          2 Timer om ugen (Bestyrelse) Education, Youth, egmon…\n# ℹ 56,839 more rows\n\n\nDisse emne-tags kan bruges til at udvælge subset af data til forskellige analyser. I custom_functions.R filen, vi indlæste tidligere, ligger en funktion der giver et overblik over hvilke tags den17-datasættet indeholder: nemlig show.all.tags(), som viser hvor mange positioner (poster) i hvor mange organisationer, der knytter sig til hvert tag.\n\nden %&gt;% show.all.tags() %&gt;% head(15)\n\n                 Positions affiliations\nA-kasse                193           14\nAcademics              927           71\nActors                  65            7\nAdministration         789           66\nAfrica                  13            1\nAlternative             45            8\nAnimals                397           50\nArchitecture          1419          130\nArt                    753          100\nArtists                245           30\nAsia                     5            1\nAward                   40            6\nBaltic countries        11            2\nBanks                  899           69\nBILH                   190           45\n\n\nhvis I skriver:\n\nden %&gt;% show.all.tags() %&gt;% enframe() \n\ntags i kombination med sector og evt. også type type er en god mode at finde frem til et spændende subset af virksomheder og eller personer.\n…lad os se hvad variablen sector indeholder. Til det kan vi bruge verbet count(), som optæller cases på en given variabel.\n\nden %&gt;% count(sector)\n\n# A tibble: 13 × 2\n   sector           n\n   &lt;chr&gt;        &lt;int&gt;\n 1 Commissions    814\n 2 Corporations  9524\n 3 Events        2270\n 4 Family         207\n 5 Foundations   6993\n 6 Municipal      320\n 7 NGO          17720\n 8 Organisation   227\n 9 Parliament    1087\n10 Politics        37\n11 State        13764\n12 VL_networks   3803\n13 &lt;NA&gt;            83\n\n\n…lad os også se på type, der giver en alternativ inddeling .\n\nden %&gt;% count(type) \n\n# A tibble: 10 × 2\n   type                     n\n   &lt;chr&gt;                &lt;int&gt;\n 1 Begivenhed            2086\n 2 Folketing              241\n 3 Fond (CVR)            1783\n 4 Kommission             772\n 5 Netvaerk (VL-gruppe)  4318\n 6 Organisation         14819\n 7 Snowball                11\n 8 Stat                 10419\n 9 Virksomhed (CVR)      9722\n10 &lt;NA&gt;                 12678\n\n\nFor eksemplets skyld lad os begynde med at ‘subsette’ datasættet, så vi kun beholder de 7989 rækker hvor en ‘affiliation’ har værdien Corporations på sector variablen.\n\nden_corp &lt;- den %&gt;% filter(sector == \"Corporations\")\n\nlad os se på hvilke tags vi kan finde her:\n\nshow.all.tags(den_corp) %&gt;% head(10)\n\n             Positions affiliations\nAnimals             37            4\nArchitecture        93           14\nBanks              384           40\nBILH               190           45\nBusiness            96           14\nBYGG               282           43\nCharity             16            1\nChildren             8            1\nClothing            11            1\nCommerce            46            6\n\n\nfunktionen has.tags() er en hjælpefunktion, der giver os enten (... result = \"affil\") en liste af navne på de organisationer, der har det eller et af de pågældende tags, eller (... result = \"name\") en liste af navne på individer der er i en af disse organisationer, eller (... result = \"den\") et nyt datasæt med kun poster i organisationer med de relevante tags. Option’en ...mode = bruges til at fortælle om vi vil have alle de poster der har der har et af tags’ne (...mode = \"or\"), eller om vi ønsker at posterne skal have alle tags’ne (...mode = \"and\"):\nLad os lave en streng vector med de Tags vi gerne vil kigge efter.\n\ntags &lt;- c(\"Banks\", \"FINA\", \"Finance\", \"Investment\", \"Insurance\")\n\nHvis vi bruger result = \"affil\" sammen med mode = \"or\" får vi alle de virksomheder, der har et af de pågældende tags:\n\nden_corp %&gt;% has.tags(tags, result = \"affil\", silent = TRUE, mode = \"or\") %&gt;% head(10)\n\n [1] \"A/S DANSK ERHVERVSINVESTERING\" \"ALD Automotive\"               \n [3] \"Aleris (Bestyrelse)\"           \"Alm. Brand\"                   \n [5] \"Alpha Holding\"                 \"ALTOR EQUITY PARTNERS A/S\"    \n [7] \"AP Pension\"                    \"Arbejdernes Landsbank\"        \n [9] \"Axcelfuture (Advisory Board)\"  \"Bank DNB Nord\"                \n\n\nHvis vi bruger result = \"name\" sammen med mode = \"or\" får vi alle de personer, der har poster i virksomheder med et af de pågældende tags:\n\nden_corp %&gt;% has.tags(tags, result = \"name\", silent = TRUE, mode = \"or\") %&gt;% head(10)\n\n [1] \"Asger Ib Mardahl-Hansen\"            \"Hans Ole Jensen\"                   \n [3] \"Lars Groenborg Eskesen\"             \"Michael Noergaard\"                 \n [5] \"Thorkild Engell Jensen\"             \"Gilles Jean-Noël Momper\"           \n [7] \"Guillaume Joseph Emile de Leobardy\" \"Michael John Masterson\"            \n [9] \"Tim Torben Albertsen\"               \"Björn Nordenvall\"                  \n\n\nHvis vi bruger result = \"den\" sammen med mode = \"or\" får vi et subset af data med alle de poster der har et af de pågældende tags. Det data assigner vi (&lt;-) til et nyt dataobjekt den_fina:\n\nden_fina &lt;- den_corp %&gt;% has.tags(tags, result = \"den\", silent = TRUE, mode = \"or\")\ndim(den_fina)\n\n[1] 989  10"
  },
  {
    "objectID": "session3.html#orbis",
    "href": "session3.html#orbis",
    "title": "Indsamling af netværksdata og konstruktion af netværksobjekter",
    "section": "Orbis",
    "text": "Orbis\nEn anden kilde til (netværks-)data om virksomheder er Orbis. Orbis er en database der indeholder information om virksomheder fra hele verden - omkring 400.000.000 selskaber. Databasen trækker data fra mere end 170 forskellige kilderm som standardiseres og linkes på en måde der muliggør sammenlinging. På virksomhedsniveau indeholder orbis blandt meget andet geografisk data, juridisk data, finansiel data, ejerskabsdata mv. om den enkelte virksomhed. Fra et netværksperspektiv er databasen interessant fordi den desuden indeholder (aktuel og historisk) data om virksomhedernes bestyrelse og direktion (m.v.). I det følgende skal vi se hvordan man trækker et bestyrelses-(netværks-)datasæt fra orbis.\n\n\n\n\n\n\nNote\n\n\n\nSom med al anden data (særligt data man ikke selv har frembragt), skal man med Orbis være opmærksom på en række\nSkim evt. denne rapport fra OECD om Orbis’ dækningsgrad. Eller tag et kig på (Heemskerk et al. 2018) om bl.a. ‘completeness’ og problemer med ‘entity resolution’ - optræder det samme firma eller den samme person flere gange med forskllige versioner af det navn. Det er ikke problemer I behøver at løse, men noget det er værd at bemærke, når man præsenterer den data man analyserer!\n\n\nOrbis kan tilgås via jeres login til CBS’s bibliotek: Orbis via cbs\n\nAt ‘bygge’ et søgefilter på Orbis\nDet første man skal tænke over er hvilke filtre, der er nødvendige for at hente det subset af virksomheder man er interesseret i. Der er selvfølgelig et hav af muligheder.\n\n\n\nOrbis forside\n\n\n\nUnder Company, kan man under fx vælge Standardized legal forms vælge kun ‘Private limited companies’ eller også ‘Public limited companies’. Man kan også under Number of employees vælge kun at kigge på virksomheder af en hvis størrelse.\nUnder Location kan man sætte forskellige geografiske filtre, både lande, regioner m.v., men også forskellige klassifikationer.\nUnder Activities and industry kan man under Industri classifications vælge mellem forskellige branche-klassifikationer og herunder udvælge en (eller flere) bestemt(e) branche(r). Man kan desuden under Entity type afgrænse virksomhedstype yderligere. En anden mulighed er at man definerer ‘fritekst’ søgning under Activity text search, hvor man under ‘scope’ vælger hvilke datafelter, der skal søges i og under ‘Free text’ skriver hvad der skal søges efter. \n\nNår man har ‘bygget’ sit filter kan man se hvad de forskellige filtre gør og hvad de til sammen giver af resultat. Næste skridt er View results \n\n\nTilføj bestyrelsesoplysninger til vores data\nHer kan vi se alle de virksomheder, der lever op til vores søgekriterier. Det vi gerne vil nu er at tilføje bestyrelsesdata. Klik på Add/remove columns øverst til højre.  Scroller man lidt ned i venstre kolonne og klikker på feltet Directors and managers, får man i den midsterste kolonne en række valgmuligheder:  Vælg som minimum 1) Full name, 2) UCI, 3) Job title, 4) Current or previous.\nUnder Other personal information og Other role information i venstre kolonne kan man tilføje yderligere information om personen og dennes rolle. På personniveau fx. køn og nationalitet mv. På rolleniveau kan det være nyttigt at tilføje ‘Type of role’ og ‘Board, committee or department’ og evt. ‘Level of responsibility’, da det kan give mulighed for at fokusere kun på bestyrelse og direktion.\nHvis man klikker på det lille filter-ikon under fx ‘Full name’ i den venstre kolonne får man mulighed for at filtrere på rollerne. Det kan være nyttigt her at forholde sig til om man både vil have nuværende og tidligere roller med. Har man tilføjet variablen Current or previous, kan man altid filtrere senere, men hvis man ikke gør det her skal man være opmærksom på at data kommer til at indeholde mange rækker (!)\nDet er også muligt at tilføje yderligere virksomhedsdata.\nNår de variable man gerne vil have med er valg, trykker man Apply og så er vi klar til at eksportere data.\n\n\nEksporter data til xlsx\nKlik på “Excel”.. I den eksport-menu, der kommer op er det vigtigt, at man under Options for excel vælger ‘Repeat single item data’ inden man trykker Export.\n\n\n\n\n\n\n\n\nNår Orbis har klargjort data, kan man downloade filen til sin computer.\n\n\nEksempel med alkohol og tobak fra Orbis\nJeg har tidligere downloadet et datasæt med alle aktive, public limited companies med branchekoderne Alkohol og tobak (‘Manufacture of beverages’ NACE#11(-soft drinks 11.0.7) & ‘Manufacture of tobacco products’ NACE#12)\nI kan downloade datasættet her: Download Data og lægge filen i data mappen i vores Rprojekt mappe. Filen kan også hentes på Canvas.\nDer er også en ny funktion i custom_functions scriptet, read_orbisxlsx(), det er en genvej til at indlæse datafiler fra Orbis. For at bruge den funktion skal I download en ny udgave af custom_functions her Download file og lægge den i functions/ mappen i Rprojekt mappen (dvs. erstatte den anden). Filen kan også hentes på Canvas. Når filen ligger i functions mappen kan vi “source” den og anvende funktionen.\n\nsource(\"functions/custom_functions.R\", echo = FALSE)\n\nNu kan vi indlæse orbis-filen tobaco_and_alcohol.xlsx ved at indsætten stien til filen (data/tobaco_and_alcohol.xlsx) med read_orbisxlsx():\n\ndf &lt;- read_orbisxlsx(path = \"data/tobaco_and_alcohol.xlsx\")\n\nWarning: Unknown or uninitialised column: `assets`.\n\n\nOrbis variable names updated: \n\nDMFull name                                       =&gt; name\nDMUCI (Unique Contact Identifier)                 =&gt; person_id\nCompany name Latin alphabet                       =&gt; affiliation\nCountry ISO code                                  =&gt; affiliation_country\nDMJob title (in English)                          =&gt; role\nDMBoard, committee or department                  =&gt; board_type\nDMType of role                                    =&gt; role_type\nDMLevel of responsibility                         =&gt; role_level\nDMAppointment date                                =&gt; appointment\nDMResignation date                                =&gt; resignation\nDMCurrent or previous                             =&gt; role_status\nNACE Rev. 2, core code (4 digits)                 =&gt; sector\nOperating revenue (Turnover) th USD Last avail. yr=&gt; revenue\nNumber of employees Last avail. yr                =&gt; n_employees\nCSH - Orbis ID number                             =&gt; csh_orbis_id\nCSH - Name                                        =&gt; csh_name\nCSH - Country ISO code                            =&gt; csh_country\nGUO - Name                                        =&gt; guo_name\nGUO - Country ISO code                            =&gt; guo_country\nDUO - Name                                        =&gt; duo_name\nDUO - Country ISO code                            =&gt; duo_country\n\n\nNew variables added: \nperson {TRUE/FALSE}\n\n\nread_orbisxlsx funktionen oversætter bl.a. variabelnavne fra orbis til noget mere meningsfuld og læseligt. Vigtigt: Current or previous variablen hedder nu role_status. Der er også en ny variabel, person, som ud fra identifikationsnummeret ‘gætter’ om personen faktisk er en person.\nLad os til at begynde med reducere vores data til kun aktive/current poster og poster der faktisk er personer:\n\ndf_current &lt;- df %&gt;% \n  filter(person == TRUE & role_status == \"Current\")\n\nEn udfordring ved bestyrelsesdata fra Orbis er at det er uklart/varierende hvor mange individer, der er registreret for hver virksomhed:\n\ndf_current %&gt;% \n  distinct(name, affiliation) %&gt;% \n  summarise(n = n_distinct(name), .by = affiliation) %&gt;% \n  summary(n)\n\n affiliation              n           \n Length:5938        Min.   :   1.000  \n Class :character   1st Qu.:   1.000  \n Mode  :character   Median :   2.000  \n                    Mean   :   4.303  \n                    3rd Qu.:   4.000  \n                    Max.   :1140.000  \n\n\nGennemsnittet har 4 ‘directors’, der er en del en mandsbestyrelser og én virksomhed har 1140 (!) ‘directors’. Det skyldes at alle mulige lavere direktører er registreret. Vi kan prøve at løse noget af det ved at kode en ny variabel, hvor vi prøver at indfange meningen af en rolle fra role_level-variablen (som i Orbis hed DMLevel of responsibility) og fra role_type (som i Orbis hed DMType of role)\n\ndf_current &lt;- df_current %&gt;% \n  mutate(role_level_rec = case_when(\n    grepl(\"member\", role_level, ignore.case = T) ~ \"member\",\n    grepl(\"executive\", role_level, ignore.case = T) ~ \"executive\",\n    grepl(\"vice (pres|chair)\", role_level, ignore.case = T) ~ \"vice chairman\", \n    grepl(\"president|chairman\", role_level, ignore.case = T) ~ \"chairman\", \n    .default = \"other\"))\n\ndf_current &lt;- df_current %&gt;% \n  mutate(role_level_rec = case_when(\n    role_level_rec == \"other\" & \n      (grepl(\"SenMan\", role_type, ignore.case = T) | \n         grepl(\"manager\", role_level, ignore.case = T)) ~ \"executive\",\n    role_level_rec == \"other\" & \n      grepl(\"chief\", role_level, ignore.case = T) ~ \"executive\",\n    .default = role_level_rec))\n\n\ndf_current &lt;- df_current %&gt;% \n  filter(role_level_rec %in% c(\"member\",\"chairman\", \"vice chairman\",\"executive\"))\n\n\ndf_current %&gt;% ungroup() %&gt;% count(role_level, sort = TRUE)\n\n# A tibble: 403 × 2\n   role_level                                             n\n   &lt;chr&gt;                                              &lt;int&gt;\n 1 Member                                             10438\n 2 Highest executive                                   2530\n 3 President / Chairman                                2246\n 4 Representative                                      2158\n 5 Unspecified executive                                991\n 6 Manager                                              879\n 7 Executive                                            685\n 8 Vice President / Vice Chairman                       589\n 9 Chief Financial Officer (CFO); Financial executive   566\n10 Chief Officer; Executive                             445\n# ℹ 393 more rows\n\n\nVi kan starte med lige at se på hvor mange ‘board members’ hver virksomhed har: Som I kan se er der nogle meget store ‘boards’. Det er et af problemerne med Orbis, nemlig at det er uklart hvad der er registreret per virksomhed.\n\ndf_current %&gt;% distinct(name, affiliation) %&gt;% count(affiliation, sort = TRUE)\n\n# A tibble: 5,927 × 2\n   affiliation                          n\n   &lt;chr&gt;                            &lt;int&gt;\n 1 CONSTELLATION BRANDS, INC.         834\n 2 BROWN FORMAN CORP                  300\n 3 PHILIP MORRIS INTERNATIONAL INC.   187\n 4 MOLSON COORS BEVERAGE COMPANY      172\n 5 TREASURY WINE ESTATES LIMITED      110\n 6 JAPAN TOBACCO INC                   75\n 7 ALTRIA GROUP, INC.                  67\n 8 TURNING POINT BRANDS, INC.          66\n 9 TANZANIA BREWERIES LIMITED          53\n10 SECHABA BREWERY HOLDINGS LIMITED    52\n# ℹ 5,917 more rows\n\n\nVi kan lave en ny variabel i vores datasæt, der for hvert individ tæller hvor mange virksomeder, de er knyttet til:\n\ndf_current &lt;- df_current %&gt;% group_by(name) %&gt;% mutate(n_memberships = n_distinct(affiliation))\ndf_current %&gt;% ungroup() %&gt;%  count(n_memberships)\n\n# A tibble: 9 × 2\n  n_memberships     n\n          &lt;int&gt; &lt;int&gt;\n1             1 24333\n2             2  2623\n3             3   860\n4             4   368\n5             5   265\n6             6    66\n7             7    71\n8             8    48\n9             9    18\n\n\nLad os slette personer, n = 24333, der ‘kun’ sidder i en enkelt virksomhed, da de alligevel ikke laver nogen forbindelser på tværs af virksomheder i vores netværk. Vi sletter så at sige folk i vores affiliation data, der ikke er ‘linkere’ (filter()) og samtidig sørger vi for at hvert individ kun optræder én gang per virksomhed (distinct()) - det kan jo være at nogen har mere end en rolle i samme bestyrelse (datasnavs?).\n\ndf_current &lt;- df_current %&gt;% \n  filter(n_memberships &gt; 1) %&gt;% \n  distinct(name, affiliation, .keep_all = TRUE)\n\n\nFra data til netværk.\nHusk fra sidst Session 1 (uge 6): Introduktion til netværksanalyse i R, hvordan vi kommer fra et affiliation datasæt som vi har her, med rækker der forbinder “individer” til “organisationer”. Her er et skematisk overblik.\n R-kode til at lave ‘biadjacency matricen’ med individer i rækker og affiliations i kolonner (husk sparse!)\n\nbi_adj &lt;- xtabs(data = df_current, formula = ~name + affiliation, sparse = TRUE)\n\nI dette eksempel vil vi gerne se hvordan virksomheder der fremstiller tobak og alkohol er forbundet gennem overlappende bestyrelser. Derfor vil gerne ‘udregne’ \\(affiliation \\times affiliation\\) matricen ved at gange en transponeret udgave af vores biadjacency matrice med sig selv (\\(B^T \\times B\\))\n\nadj_c     &lt;- t(bi_adj) %*% bi_adj\n\nSom altid skal vi lige lave vores adjacency matrice om til et grafobjekt med igraph-funktionen graph_from_adjacency_matrix(). Her har vi et “undirected”, “weighted” netværk, hvor vi ser bort fra diagonalen:\n\ngr &lt;- graph_from_adjacency_matrix(adj_c, mode = \"undirected\", diag = FALSE, weighted = TRUE)\n\nLad os som det første kigge på et helt minimalistisk plot af vores netværk:\n\ngr %&gt;% ggraph() +\n  geom_edge_link0() +\n  geom_node_point() +\n  theme_graph()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nSom I kan se består netværket af flere ‘klynger’. Det kaldes i netværksanalysesprog for komponenter. Det kommer vi tilbage til i løbet af kurset, men en netværkskomponent er et sammenhængende sæt af vertices. Lad os i første omgang prøve at bruge vores branchekode-variabel til at se om vi kan finde noget logik i hvordan komponenterne ser ud. Er der komponenter, hvor der er bestyrelsesoverlap (dvs. edges) mellem virksomheder der fremstiller hhv. alkohol og tobak. Det kræver at vi får lagt vores branchekode ind i grafobjektet som en vertex attribute.\n\n\nTilføj vertice attributes\nDet gør vi ved først at lave et nyt datasæt, som vi kalder sector, der indeholder én række for hver virksomhed + branchekode (distinct(affiliation, sector)), dernæst overskriver vi sector, så vi kun har de to første cifre i branchekoden (da vi er ligeglade med underkategorier), altså en ‘substring’, substr(sector, start = 1, stop = 2), endelig omkoder vi branchekodens talværdier til et label (case_when(sector == \"12\"~\"Tobak\", sector == \"11\"~\"Alkohol\", .default = NA)). Logikken i case_when-verbet er at man har et logisk udtryk efterfult af ~ hvad der så skal stå, et nyt logisk udtryk efterfulgt af ~ hvad der så skal stå. Altså formen, hvis~så, hvis~så osv., afsluttende med .default =, hvor vi definerer hvad værdien skal være, hvis ingen af de logisk udtryk passer.\n\n# add sector as attribute...\nsector     &lt;- df_current %&gt;% ungroup() %&gt;% \n  distinct(affiliation, sector) %&gt;% \n  mutate(sector = substr(sector, start = 1, stop = 2)) %&gt;% \n  mutate(sector = case_when(\n    sector == \"12\"~\"Tobak\",\n    sector == \"11\"~\"Alkohol\",\n    .default = NA))\n\nNu skal vi have ‘merget’ vores sector variabel på netværksobjektet. Til det formål skal vi først lige lave en lille data.frame, der indeholder navnene på vores vertices (altså virksomhedsnavnene), sorteret på samme måde som i grafobjektet. Husk fra sidst hvordan vi tilgår vertice attributes i vores grafobjekt vha. V()\nVi laver her en data.frame med variablen affiliation, der indeholder virksohedsnavne fra vores grafobjekt.\n\nadd_sector   &lt;- data.frame(affiliation = V(gr)$name)\n\nNu mangler vi bare at flette sectorvariablen på så de rigtige værdier kommer til at stå ud for de rigtige virksomhedsnavne. Her har tidyverse en genial funktion, left_join(), som gør netop det. Hvis vi har datasæt x, vores data.frame med virksomhedsnavne, og datasæt y, vores sector datasæt med virksomhedsnavne og branchelabel, så gør left_join det at den ved at matche på virksomhedsnavnet, by = \"affiliation, fletter den anden variabel i y på x, altså left_join’er y på x.\n\nadd_sector   &lt;- left_join(add_sector, sector, by = \"affiliation\")\n\nNu har vi et datasæt med branchekoder i, der er ordnet ligesom vores grafobjekt, og vi kan derfor assign’e &lt;- variablen med branche koder som en ny vertex attribute i vores grafobjekt.\n\nV(gr)$sector &lt;- add_sector$sector\n\nLad os nu lave vores visualisering igen, hvor vi farvelægger noderne efter branche. Vi kommer senere til detaljer i plot funktionerne. Kort fortalt om visualisering:\n\nfunktionen ggraph() opretter et tilsyneladende tomt plot (tilsyneladende fordi den faktisk udregner et layout for vertices i vores data)\nfunktionen geom_edge_link0() plotter vores edges som en ‘streg’/et link. Der er også andre muligheder fx. geom_edge_arc() der plotter dem som en bue.\nfunktionen geom_node_point() der plotter vores noder som en ‘cirkel’/point.\n\n\ninden for hver af disse geom'er kan vi sætte en masse options. Blandt andet kan vi definere nogle aesthetics. lad os bruge sector til at sætte farven på vores punkter (mapping = aes(color = sector)). Det betyder at vi lader farven på punkter følge værdierne på en bestemt variabel.\n\n\ngr %&gt;% ggraph() +\n  geom_edge_link0() +\n  geom_node_point(mapping = aes(color = sector)) +\n  theme_graph()\n\nUsing \"stress\" as default layout\n\n\n\n\n\n\n\n\n\nMed undtagelse af primært den største komponent ser komponenterne ud til at være ret branche homogene. Der sker noget andet i den største komponent, så lad os fokusere vores visualisering på den største komponent i netværket.\nigraph pakken har en funktion, der giver os netværkets største komponent largest_component()\n\n# 1) først trækker vi netværket ud for den største komponent\ngr %&gt;% largest_component() %&gt;% \n# 2) laver et plot  \n  ggraph() + \n# 3) tilføjer edges, som vi giver en fast farve og størrelse:\n  geom_edge_link0(color = \"gray40\", edge_width = .6) +\n# 4) tilføjer vertices, farvelagt efter sector og med en fast størrelse:\n  geom_node_point(aes(color = sector), size = 3) +\n# 5) Tilføjer labels for udvalgte vertices:\n   geom_node_label(aes(filter = grepl(\"british american tobacco plc|carlsberg a/S|PHILIP MORRIS INTERNATIONAL INC|HEINEKEN N\\\\.|diageo p\", name, ignore.case = T), label = name, color = sector), size = 3, repel = TRUE) +\n# 6) Ændrer farver og labels.\n  scale_color_manual(values = c(\"salmon2\", \"steelblue\", \"grey\"), \n                     labels = c(\"Alkohol\", \"Tobak\", \"NA\")) +\n# 7) Tilføjer overskrifter og navn på labels\n  labs(title = \"'Corporate interlocks' i alkohol- og tobaksbrancherne\", \n       subtitle = \"den største komponent\",\n       color = \"Branche\") +\n# 8) Tilføjer et tema der er flot til netværk...\n  theme_graph()\n\nUsing \"stress\" as default layout"
  },
  {
    "objectID": "session3.html#cvr",
    "href": "session3.html#cvr",
    "title": "Indsamling af netværksdata og konstruktion af netværksobjekter",
    "section": "CVR",
    "text": "CVR\nEn tredje kilde til bestyrelsesnetværk er Det centrale virksomhedsregister i Danmark (https://datacvr.virk.dk/). Her kan man lave afgrænsede søgninger på danske virksomheder ud fra bl.a. geografi: Kommune eller region, virksomhedsstatus (aktive, ophørt, under konkurs etc.), virksomhedsform (aktieselskab, anpartsselskab etc.), startdato og branche.\n\nI dette eksempel har jeg valgt “Region = Grønland”, “Virksomhedsstatus = Aktive”, “Virksomhedsform = Aktieselskab”. Det giver os 199 virksomheder. Hvis man scroller ned kan man eksportere data som en xlsx fil.\ndownload filen her\nDownload Data\nHvis I lægger filen i datamappen under Rprojekt-mappen, kan den indlæses med read_xlsx() her\n\ngronland_as &lt;- read_xlsx(\"data/CVRudtræk_AS_Grønland_2025-02-17.xlsx\")\nhead(gronland_as)\n\n# A tibble: 6 × 12\n  `CVR-nummer/REG-nummer` Startdato  Ophørsdato Navn       Adresse Postnr. By   \n  &lt;chr&gt;                   &lt;chr&gt;      &lt;lgl&gt;      &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;\n1 12486162                2008-06-01 NA         GREENLAND… Vatika… 3920    Qaqo…\n2 12706952                2013-12-23 NA         SIKUKI NU… Issort… 3905    Nuus…\n3 12036329                2002-07-01 NA         IMARTUNEQ… C/O Po… 3900    Nuuk \n4 40976191                2019-10-15 NA         Nuuk Wate… Imaneq… 3900    Nuuk \n5 45203573                2024-11-12 NA         Maniitsoq… C/O Ka… 3912    Mani…\n6 12579853                2009-12-01 NA         ILLIT FOR… Eqalug… 3905    Nuus…\n# ℹ 5 more variables: Virksomhedsform &lt;chr&gt;, Hovedbranche &lt;chr&gt;,\n#   Telefonnr &lt;chr&gt;, Email &lt;chr&gt;, Reklamebeskyttet &lt;chr&gt;\n\n\nDet kræver lidt mere arbejde at komme frem til et bestyrelsesnetværk her fra. Det er nemlig kun virksomhedsdata vi får ud her. Næste skridt er at gå ind på hver virksomhed på cvr og finde bestyrelsesmedlemmerne:\n\nSøg på CVR nummer (eller virksomhedsnavn) i søgefeltet:\nKlik på “Tegningsregel, personkreds og revisor”\n\n\n\nKopier bestyrelsen til et excel-ark:\n\n Og så fortsætter man ellers bare med alle 199 virksomheder, til man har et komplet excel ark med alle bestyrelsesmedlemmer for alle virksomheder.\n\n\n\n\n\n\nNote\n\n\n\nDet tager noget tid!! (Man kan evt. spørge øvelseslæreren om det evt. er muligt at trække data på en anden måde via fx Elitedatabasen eller direkte fra CVR!)"
  },
  {
    "objectID": "kursusmateriale.html",
    "href": "kursusmateriale.html",
    "title": "Kursusmateriale",
    "section": "",
    "text": "Her er et overblik over de forskellige elementer vi skal igennem i løbet af kursets i alt 7 øvelsessessioner."
  },
  {
    "objectID": "kursusmateriale.html#session-1-intro-til-netværksanalyse-i-r",
    "href": "kursusmateriale.html#session-1-intro-til-netværksanalyse-i-r",
    "title": "Kursusmateriale",
    "section": "Session 1 — Intro til netværksanalyse i R",
    "text": "Session 1 — Intro til netværksanalyse i R\nFormålet med denne øvelsesgang er at lære grundlæggende netværkfunktioner i R. I skal have installeret R og Rstudio inden vi starter. Vi forventer at gennemgå, hvordan man konstruerer forskellige netværksobjekter og matricer, og hvordan man visualisere simple netværk i Rstudio, herunder hvordan man tilføjer illustrative egenskaber til netværksobjekter. Endelig vil vi diskutere, hvilke emner og netværk, I kan arbejde med i jeres eksamensopgaver og udarbejde foreløbige undersøgelsesspørgsmål. Gør jer selv den tjeneste, at brush-up jeres R skills: se Intro til R og Tidyverse. Selv to timer brugt på at genopfriske den basale syntaks er godt givet ud.\nDer er flere online ressourcer tilgængelige, som hjælper med dette, såsom: codecademy Eller denne, mere traditionelle, gennemgang: r-tutorial (første lektion “What is R Programming Language? Introduction & Basics” kan springes over, det er mere en slags salgstale for hvorfor man skal bruge R.)"
  },
  {
    "objectID": "kursusmateriale.html#session-2-sammenhængskraft-korteste-stier-kliker",
    "href": "kursusmateriale.html#session-2-sammenhængskraft-korteste-stier-kliker",
    "title": "Kursusmateriale",
    "section": "Session 2 — Sammenhængskraft, korteste stier, kliker",
    "text": "Session 2 — Sammenhængskraft, korteste stier, kliker\nI denne session arbejder vi især med begreberne densitet, stilængde, diameter og komponenter vs isolerede noder."
  },
  {
    "objectID": "kursusmateriale.html#session-3-indsamling-af-netværksdata-og-konstruktion-af-netværksobjekter",
    "href": "kursusmateriale.html#session-3-indsamling-af-netværksdata-og-konstruktion-af-netværksobjekter",
    "title": "Kursusmateriale",
    "section": "Session 3 — Indsamling af netværksdata og konstruktion af netværksobjekter",
    "text": "Session 3 — Indsamling af netværksdata og konstruktion af netværksobjekter\nDenne øvelsesgang vil fokusere på to ting; datakilder og transformering af forskellige dataformater til en netværksdatastruktur."
  },
  {
    "objectID": "kursusmateriale.html#session-4-centralitetsanalyse",
    "href": "kursusmateriale.html#session-4-centralitetsanalyse",
    "title": "Kursusmateriale",
    "section": "Session 4 — Centralitetsanalyse",
    "text": "Session 4 — Centralitetsanalyse\nI denne øvelsesgang gennemgår vi, hvordan man måler noders overordnet centralitet i form af degree, closeness og betweenness samt graden af centralisering i et netværk. Endelig ser vi også på, hvordan man kan visualisere centrale aktører i et netværk. I får, som altid, mulighed for at arbejde med at analysere netværksmålene på jeres egne data."
  },
  {
    "objectID": "kursusmateriale.html#session-5-analyse-af-strategiske-netværksrolle",
    "href": "kursusmateriale.html#session-5-analyse-af-strategiske-netværksrolle",
    "title": "Kursusmateriale",
    "section": "Session 5 — Analyse af strategiske netværksrolle",
    "text": "Session 5 — Analyse af strategiske netværksrolle\nI denne session har vi fokus på Burts constraint som et mål for brobygning vs indlejrethed i redundente forbindelser"
  },
  {
    "objectID": "kursusmateriale.html#session-6-identifikation-af-communities",
    "href": "kursusmateriale.html#session-6-identifikation-af-communities",
    "title": "Kursusmateriale",
    "section": "Session 6 — Identifikation af communities",
    "text": "Session 6 — Identifikation af communities\nDenne øvelsesgang fokuserer på at lære at benytte de forskellige metoder til at finde communities i R samt at benytte mål som clustering coefficient. Vi vil ligeledes gennemgå, hvordan man plotter et netværk på forskellige communities og hvordan man kan undersøge karakteristika for forskellige communities."
  },
  {
    "objectID": "kursusmateriale.html#session-7-visualisering-af-netværk",
    "href": "kursusmateriale.html#session-7-visualisering-af-netværk",
    "title": "Kursusmateriale",
    "section": "Session 7 — Visualisering af netværk",
    "text": "Session 7 — Visualisering af netværk\nI denne øvelse vil I lære om mere avancerede teknikker til visualisering af netværk ved hjælp af ggraph-pakken i R. I vil lære, hvordan man anvender forskellige layouts, farvepaletter og labels for at gøre netværksvisualiseringerne mere informative. Vi vil gennemgå, hvordan man kan bruge forskellige typer af skalaer for at fremhæve bestemte aspekter af netværket."
  },
  {
    "objectID": "session1.html",
    "href": "session1.html",
    "title": "Introduktion til netværksanalyse i R",
    "section": "",
    "text": "I denne øvelses-session skal vi indlæse et netværksdatasæt og lave den første simple netværksgraf. Datasættet vi kigger på er kommer vi i øvrigt til at gå meget mere i dybden med se Session 2 (uge 7).\nDownload script\nFørst indlæser vi de pakker vi kommer til at bruge:\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(ggraph)\nlibrary(igraph)\nlibrary(Matrix)"
  },
  {
    "objectID": "session1.html#adjacency-matricer",
    "href": "session1.html#adjacency-matricer",
    "title": "Introduktion til netværksanalyse i R",
    "section": "Adjacency matricer",
    "text": "Adjacency matricer\nEt at netværk (i matematiksprog en graf - som ikke er at forveksle med en graf som vi normalt kender den som fx en linje i et koordinatsystem) består af relationer mellem et eller to sæt af elementer, fx. relationer mellem individer (venskaber) eller relationer mellem individer og organisationer (poster/medlemskaber). Elementerne kalder vi vertices (eller noder) og forbindelserne kalder vi edges.\n\nEt sæt vertices\nHvis netværket består af ét sæt af elementer, fx. individer, kalder vi matrix repræsentationen for en adjacency matrice (adjacent betyder ‘tilstødende’, altså ‘forbundet’). En adjacency matrice \\(A\\) for et netværk med \\(n\\)elementer \\(V = \\begin{pmatrix} v_1 & v_2 & \\dots & v_n\\end{pmatrix}\\) definerer vi således som en \\(n \\times n\\) matrice \\(A\\) hvor:\n\\[\na_{ij} =\n\\begin{cases}\n1, & \\text{hvis der er en forbindelse mellem vertex } i \\text{ og vertex } j \\\\\n0, & \\text{eller}\n\\end{cases}\n\\] dvs.\n\\[A =\n\\begin{pmatrix}\n0 & 1 & 1 & 0 \\\\\n1 & 0 & 1 & 1 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 1 & 0\n\\end{pmatrix}\n\\]\n\n\nTo sæt vertices\nHvis netværket derimod består af to distinkte sæt vertices, fx. individer og organisationer, hvor der kun er forbindelser på tværs af de to sæt om ikke indenfor dem, kalder vi det et bipartite netværk, kalder vi matrix repræsentationen en biadjacency matrice (nogen gange også incidence matrice).\nEn biadjacency matrice for et bipartite netværk med to sæt vertices \\(V = \\{ v_1, v_2, \\dots, v_n \\}\\text{ og }U = \\{ u_1, u_2, \\dots, u_n \\}\\) er således en \\(n \\times m\\) matrice \\(B\\) hvor: \\[\nB_{ij} =\n\\begin{cases}\n1 & \\text{hvis der er en edge/forbindelse mellem vertex } u_i \\text{ i sættet } U \\text{ og vertex } v_j \\text{ i sættet } V, \\\\\n0 & \\text{hvis der ikke er en edge/forbindelse mellem } u_i \\text{ og vertex } v_j.\n\\end{cases}\n\\]\ndvs.\n\\[\nB = \\begin{pmatrix}\n1 & 1 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1 \\\\\n1 & 0 & 1\n\\end{pmatrix}\n\\]\n\n\ngraf projektion\nVores bipartite netværk har som bekendt to forskellige typer af vertices \\(V(individer) = \\{ v_1, v_2, \\dots, v_n \\}\\text{ og }U(organisationer) = \\{ u_1, u_2, \\dots, u_n \\}\\). Individ1 er forbundet til Organisation1 og Organisation2, Individ2 er forbundet til Organisation2… osv. Med lidt “simpel” matrix regning kan vi hurtigt udregne to nye netværk, nemlig \\(Individ \\times Individ\\) netværket (altså hvilke individer er forbundet ‘gennem’ en eller flere organisationer) og \\(Organisation \\times Organisation\\) netværket (altså hvilke organisationer er forbundet fordi de deler individer):\n\nindivid x individ\nVed at gange hele matricen \\(B\\) med en transponeret version af \\(B\\), \\(B^T\\) får vi en \\(n \\times n\\) matrice for \\(V\\) sættet, altså en \\(individ \\times individ\\):\n\\[M_v = B \\times B^T = \\begin{pmatrix}\n\\textcolor{red}{1} & \\textcolor{red}{1} & \\textcolor{red}{0} \\\\\n\\textcolor{blue}{0} & \\textcolor{blue}{1} & \\textcolor{blue}{0} \\\\\n\\textcolor{green}{0} & \\textcolor{green}{0} & \\textcolor{green}{1} \\\\\n\\textcolor{purple}{1} & \\textcolor{purple}{0} & \\textcolor{purple}{1}\n\\end{pmatrix}\n\\times\n\\begin{pmatrix}\n\\textcolor{red}{1} & \\textcolor{blue}{0} & \\textcolor{green}{0} & \\textcolor{purple}{1} \\\\\n\\textcolor{red}{1} & \\textcolor{blue}{1} & \\textcolor{green}{0} & \\textcolor{purple}{0} \\\\\n\\textcolor{red}{0} & \\textcolor{blue}{0} & \\textcolor{green}{1} & \\textcolor{purple}{1}\n\\end{pmatrix} \\text{farverne repræsenterer individrækkerne}\\] \\[=\\begin{pmatrix}\n\\textcolor{red}{1} \\times \\textcolor{red}{1} + \\textcolor{red}{1} \\times \\textcolor{red}{0} + \\textcolor{red}{0} \\times \\textcolor{red}{0} &\n\\textcolor{red}{1} \\times \\textcolor{blue}{0} + \\textcolor{red}{1} \\times \\textcolor{blue}{1} + \\textcolor{red}{0} \\times \\textcolor{blue}{0} &\n\\textcolor{red}{1} \\times \\textcolor{green}{0} + \\textcolor{red}{1} \\times \\textcolor{green}{0} + \\textcolor{red}{0} \\times \\textcolor{green}{1} &\n\\textcolor{red}{1} \\times \\textcolor{purple}{1} + \\textcolor{red}{1} \\times \\textcolor{purple}{0} + \\textcolor{red}{0} \\times \\textcolor{purple}{1} \\\\\n\\textcolor{blue}{0} \\times \\textcolor{red}{1} + \\textcolor{blue}{1} \\times \\textcolor{red}{0} + \\textcolor{blue}{0} \\times \\textcolor{red}{0} &\n\\textcolor{blue}{0} \\times \\textcolor{blue}{0} + \\textcolor{blue}{1} \\times \\textcolor{blue}{1} + \\textcolor{blue}{0} \\times \\textcolor{blue}{0} &\n\\textcolor{blue}{0} \\times \\textcolor{green}{0} + \\textcolor{blue}{1} \\times \\textcolor{green}{0} + \\textcolor{blue}{0} \\times \\textcolor{green}{1} &\n\\textcolor{blue}{0} \\times \\textcolor{purple}{1} + \\textcolor{blue}{1} \\times \\textcolor{purple}{0} + \\textcolor{blue}{0} \\times \\textcolor{purple}{1} \\\\\n\\textcolor{green}{0} \\times \\textcolor{red}{1} + \\textcolor{green}{0} \\times \\textcolor{red}{0} + \\textcolor{green}{1} \\times \\textcolor{red}{0} &\n\\textcolor{green}{0} \\times \\textcolor{blue}{0} + \\textcolor{green}{0} \\times \\textcolor{blue}{1} + \\textcolor{green}{1} \\times \\textcolor{blue}{0} &\n\\textcolor{green}{0} \\times \\textcolor{green}{0} + \\textcolor{green}{0} \\times \\textcolor{green}{0} + \\textcolor{green}{1} \\times \\textcolor{green}{1} &\n\\textcolor{green}{0} \\times \\textcolor{purple}{1} + \\textcolor{green}{0} \\times \\textcolor{purple}{0} + \\textcolor{green}{1} \\times \\textcolor{purple}{1} \\\\\n\\textcolor{purple}{1} \\times \\textcolor{red}{1} + \\textcolor{purple}{0} \\times \\textcolor{red}{0} + \\textcolor{purple}{1} \\times \\textcolor{red}{0} &\n\\textcolor{purple}{1} \\times \\textcolor{blue}{0} + \\textcolor{purple}{0} \\times \\textcolor{blue}{1} + \\textcolor{purple}{1} \\times \\textcolor{blue}{0} &\n\\textcolor{purple}{1} \\times \\textcolor{green}{0} + \\textcolor{purple}{0} \\times \\textcolor{green}{0} + \\textcolor{purple}{1} \\times \\textcolor{green}{1} &\n\\textcolor{purple}{1} \\times \\textcolor{purple}{1} + \\textcolor{purple}{0} \\times \\textcolor{purple}{0} + \\textcolor{purple}{1} \\times \\textcolor{purple}{1}  \n\\end{pmatrix}\n\\]\n\\[= \\begin{pmatrix}\n\\textcolor{red}{2} & 1 & 0 & 1 \\\\\n1 & \\textcolor{blue}{1} & 0 & 0 \\\\\n0 & 0 & \\textcolor{green}{1} & 1 \\\\\n1 & 0 & 1 & \\textcolor{purple}{2}\n\\end{pmatrix}\n\\]\nMatrix \\(M_v\\) fortæller os i diagonalen, hvor mange gange hvert individ ‘møder sig selv’ (læs: hvor mange organisationer de er medlem af), uden for diagonalen fortæller det os at i1 (individ1) har fælles organisationer med både både i2 og i4 mens i2 kun deler organisation med én, nemlig i1. I4 har også to fælles organisationer, nemlig med i1 og i3, mens i3 også kun har én fælles tilknytning, nemlig med i4.\n\n\norganisation x organisation\nVi kan også gøre det omvendt: Ved at en transponeret version af \\(B\\), \\(B^T\\), med \\(B\\) får vi en \\(m \\times m\\) matrice for \\(U\\) sættet, altså en \\(organisation \\times organisation\\):\n\\[M_u = B^T \\times  B= \\begin{pmatrix}\n\\textcolor{red}{1} & \\textcolor{red}{0} & \\textcolor{red}{0} & \\textcolor{red}{1} \\\\\n\\textcolor{blue}{1} & \\textcolor{blue}{1} & \\textcolor{blue}{0} & \\textcolor{blue}{0} \\\\\n\\textcolor{green}{0} & \\textcolor{green}{0} & \\textcolor{green}{1} & \\textcolor{green}{1}\n\\end{pmatrix}\n\\times\n\\begin{pmatrix}\n\\textcolor{red}{1} & \\textcolor{blue}{1} & \\textcolor{green}{0} \\\\\n\\textcolor{red}{0} & \\textcolor{blue}{1} & \\textcolor{green}{0} \\\\\n\\textcolor{red}{0} & \\textcolor{blue}{0} & \\textcolor{green}{1} \\\\\n\\textcolor{red}{1} & \\textcolor{blue}{0} & \\textcolor{green}{1}\n\\end{pmatrix} \\text{farverne repræsenterer organisationskolonnerne}\\]\n\\[=\\begin{pmatrix}\n\\textcolor{red}{1} \\times \\textcolor{red}{1} + \\textcolor{red}{0} \\times \\textcolor{red}{0} + \\textcolor{red}{0} \\times \\textcolor{red}{0} + \\textcolor{red}{1} \\times \\textcolor{red}{1} &\n\\textcolor{red}{1} \\times \\textcolor{blue}{1} + \\textcolor{red}{0} \\times \\textcolor{blue}{1} + \\textcolor{red}{0} \\times \\textcolor{blue}{0} + \\textcolor{red}{1} \\times \\textcolor{blue}{0}&\n\\textcolor{red}{1} \\times \\textcolor{green}{0} + \\textcolor{red}{0} \\times \\textcolor{green}{0} + \\textcolor{red}{0} \\times \\textcolor{green}{1} + \\textcolor{red}{1} \\times \\textcolor{green}{1} \\\\\n\\textcolor{blue}{1} \\times \\textcolor{red}{1} + \\textcolor{blue}{1} \\times \\textcolor{red}{0} + \\textcolor{blue}{0} \\times \\textcolor{red}{0} + \\textcolor{blue}{0} \\times \\textcolor{red}{0} &\n\\textcolor{blue}{1} \\times \\textcolor{blue}{1} + \\textcolor{blue}{1} \\times \\textcolor{blue}{1} + \\textcolor{blue}{0} \\times \\textcolor{blue}{0} + \\textcolor{blue}{0} \\times \\textcolor{blue}{0} &\n\\textcolor{blue}{1} \\times \\textcolor{green}{0} + \\textcolor{blue}{1} \\times \\textcolor{green}{0} + \\textcolor{blue}{0} \\times \\textcolor{green}{1}  + \\textcolor{blue}{0} \\times \\textcolor{green}{1} \\\\\n\\textcolor{green}{0} \\times \\textcolor{red}{1} + \\textcolor{green}{0} \\times \\textcolor{red}{1} + \\textcolor{green}{1} \\times \\textcolor{red}{0} + \\textcolor{green}{1} \\times \\textcolor{red}{1} &\n\\textcolor{green}{0} \\times \\textcolor{blue}{1} + \\textcolor{green}{0} \\times \\textcolor{blue}{1} + \\textcolor{green}{1} \\times \\textcolor{blue}{0} + \\textcolor{green}{1} \\times \\textcolor{blue}{0} &\n\\textcolor{green}{0} \\times \\textcolor{green}{0} + \\textcolor{green}{0} \\times \\textcolor{green}{0} + \\textcolor{green}{1} \\times \\textcolor{green}{1} + \\textcolor{green}{1} \\times \\textcolor{green}{1}\n\\end{pmatrix}\n\\]\n\\[= \\begin{pmatrix}\n\\textcolor{red}{2} & 1 & 1 \\\\\n1 & \\textcolor{blue}{2} & 0 \\\\\n1 & 0 & \\textcolor{green}{2}\n\\end{pmatrix}\n\\]\nMatrix \\(M_u\\) fortæller os i diagonalen, hvor mange gange hver medlemmer hver organisation har. Uden for diagonalen fortæller det os nu at o1 (organisation1) deler et medlem med både o2 og o3 mens o2 kun deler medlem med én organisation, nemlig o1. o3 har også et individ med en anden organisation, nemlig med o1.\n\n\n\n\n\n\nNote\n\n\n\nOvenstående var eksempler på hvordan vi ved hjælp af matrix regning kommer fra en biadjaceny matrice, \\(B\\) med fx individer i rækker og organisationer i kolonner, til to forskellige adjacency matricer \\(M_{individ \\times individ}\\) og \\(M_{organisation \\times organisation}\\).\n\n\\(M_{individ \\times individ} = B \\times B^T\\)\n\\(M_{organisation \\times organisation} = B^T \\times B\\)\n\n\n\nI R kode er det meget nemmere end det ser ud…\n\nx &lt;- data.frame(i = c(\"ind1\", \"ind2\", \"ind3\", \"ind4\"), org1 = c(1,0,0,1), org2= c(1,1,0,0), org3 = c(0,0,1,1), row.names = \"i\") %&gt;% as.matrix()\nx\n\n     org1 org2 org3\nind1    1    1    0\nind2    0    1    0\nind3    0    0    1\nind4    1    0    1\n\nt(x)\n\n     ind1 ind2 ind3 ind4\norg1    1    0    0    1\norg2    1    1    0    0\norg3    0    0    1    1\n\nx %*% t(x)\n\n     ind1 ind2 ind3 ind4\nind1    2    1    0    1\nind2    1    1    0    0\nind3    0    0    1    1\nind4    1    0    1    2\n\nt(x) %*% x\n\n     org1 org2 org3\norg1    2    1    1\norg2    1    2    0\norg3    1    0    2"
  },
  {
    "objectID": "session1.html#praktisk-eksempel-med-den24",
    "href": "session1.html#praktisk-eksempel-med-den24",
    "title": "Introduktion til netværksanalyse i R",
    "section": "Praktisk eksempel med den24",
    "text": "Praktisk eksempel med den24\nlad os bruge det dataobjekt vi allerede har defineret, den_corp, som indeholder alle rækker fra den24 som er personer med min. en position i noget med landbrug.\nvi kan lige se, hvordan kolonnerne NAME og AFFILIATION ser ud:\n\nden_corp %&gt;% select(NAME, AFFILIATION) \n\n# A tibble: 4,746 × 2\n   NAME                                       AFFILIATION                       \n   &lt;chr&gt;                                      &lt;chr&gt;                             \n 1 Gregers Christian Wedell-Wedellsborg 14226 GYLDENDAL A/S 58200115            \n 2 Jens Aaløse 14415                          STICKS 'N' SUSHI A/S 73342619     \n 3 Søren Søndergaard 15013                    LANDBRUG & FØDEVARER F.M.B.A. 255…\n 4 Jais Valeur 56746                          DAT-SCHAUB A/S 33353170           \n 5 Niels Dengsø Jensen 15327                  AP PENSION LIVSFORSIKRINGSAKTIESE…\n 6 Jesper Uggerhøj 14625                      Meyers Contract Catering A/S 2663…\n 7 Anders Wilhjelm 16515                      DISA INDUSTRIES A/S 18802996      \n 8 Gregers Christian Wedell-Wedellsborg 14226 MATAS OPERATIONS A/S 27528430     \n 9 Christian Høegh-Andersen 15008             DLF Seeds A/S 62556013            \n10 Jørgen Hesselbjerg Mikkelsen 75179         DANISH AGRO A.M.B.A. (Bestyrelse …\n# ℹ 4,736 more rows\n\n\nDet vil vi gerne lave til en biadjacency matrice med individer i rækker og affiliations i kolonnerne. Fordi det bliver en kæmpe tabel med 2267 rækker og 1310 kolonner, bruger vi funktionen xtabs() som gemmer data i hukommelse på en smart måde (hvis vi sætter option spare = TRUE), så vi slipper på at bruge computerhukommelse på alle ‘nullerne’ (det skal I ikke bekymre jer om)\n\nden_corp_bi &lt;- den_corp %&gt;% xtabs(formula = ~NAME + AFFILIATION, sparse = TRUE)\n\nSom I kan se har den_corp_bi nu 2267 rækker og 1310 kolonner\n\nden_corp_bi %&gt;% dim()\n\n[1] 2267 1310\n\n\nog matricen er fyldt med en masse . fordi den er sparse. De stedet i tabellen hvor der faktisk er en forbindelse mellem \\(Individ_{i}\\) og \\(Organisation_{j}\\) står der tilgengæld \\(1\\).\n\nden_corp_bi[1:10, 360:370]\n\n10 x 11 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 11 column names 'Den grønne trepart 29199', 'Den nationale arbejdsgruppe for interessenter tilknyttet nationalparkerne 25884', 'Den Operative Kontaktgruppe for Søredningstjenesten 27359' ... ]]\n\n\n                                     AFFILIATION\nNAME                                                       \n  A. Jørgensen 69797                  . . . . . . . . . . .\n  Aage Lauritzen 71670                . . . . . . . . . . .\n  Adam Carl Moltke-Huitfeldt 38972    . . . . . . . . . . .\n  Adam Paul Kybird 20002              . . . . . . . . . . .\n  Adèle Stærkær de la Motte 57286     . . . . . . . . . . .\n  Ahmed Jahoor 64777                  . . . . . . . . . . .\n  Alex Christian Pabst Pichardt 27234 . . . . . . . . . . .\n  Alex Ostersen 19728                 . . . . . . . . . . .\n  Alexander Gamborg 69611             . . . . . . . . . . 1\n  Alfred Hansen 70694                 . . 1 . . . . . . . .\n\n\nLad os implementere den besværlige matrixregning, nu i effektiv R-kode og dermed lave to adjacency matricer:\n\nden_corp_ind &lt;- den_corp_bi %*% t(den_corp_bi)\nden_corp_org &lt;- t(den_corp_bi) %*% den_corp_bi\n\nDet giver os to matricer med dimensionerne\n\ndim(den_corp_ind)\n\n[1] 2267 2267\n\n\ndvs individ x individ,\nog\n\ndim(den_corp_org)\n\n[1] 1310 1310\n\n\ndvs. organisation x organisation."
  },
  {
    "objectID": "session1.html#monopartite-netværk",
    "href": "session1.html#monopartite-netværk",
    "title": "Introduktion til netværksanalyse i R",
    "section": "(Monopartite) netværk",
    "text": "(Monopartite) netværk\n\ngraph_from_adjacency_matrix() tager, som funktionens navn indikerer en adjacency matrice, som dem vi lige har lavet, og giver et netværksobjekt som output. Funktionen har tre vigtige options: mode =, weighted = og diag =,\n\nmode kan være enten mode = \"directed\" eller mode = \"undirected\", alt efter om netværket er retningsbestemt eller ej: er A - B og B - A det samme eller to forskellige ting.\nweigthed kan være enten weighted = TRUE eller weighted = FALSE, alt efter om det har nogen betydning, hvor mange gange (eller hvor godt) A og B kender hinanden.\ndiag kan være enten diagonal = TRUE eller diagonal = FALSE, alt efter om vi er interesseret i diagonalen, dvs. A’s forbindelse til sig selv.\n\n\nI dette tilfælde, hvor vores matrice er en projektion af en medlemskabsliste, har netværket ingen retning. A kender B på samme måde som B kender A, når de sidder sammen i en bestyrelse. Matricen er vægtet, fordi A og B kan kende hinanden flere steder. Og diagonalen, den er vi ikke interesseret i.\n\ng_ind &lt;- den_corp_ind %&gt;% graph_from_adjacency_matrix(mode = \"undirected\", weighted = TRUE, diag = FALSE)\ng_ind\n\nIGRAPH 60437c9 UNW- 2267 53636 -- \n+ attr: name (v/c), weight (e/n)\n+ edges from 60437c9 (vertex names):\n [1] A. Jørgensen 69797--Anette Rosholm 70201               \n [2] A. Jørgensen 69797--Anika Walker 69547                 \n [3] A. Jørgensen 69797--Anna Bak Jäpelt 54483              \n [4] A. Jørgensen 69797--Anne Louise Dannesboe Nielsen 70151\n [5] A. Jørgensen 69797--Anne-Marie Jensen Kerstens 69795   \n [6] A. Jørgensen 69797--Astrid Dahl 70028                  \n [7] A. Jørgensen 69797--Astrid Hypolit Hansen 70030        \n [8] A. Jørgensen 69797--Astrid Kaae Søgaard 70059          \n+ ... omitted several edges\n\n\nEt grafobjekt fra Igraph er et særligt dataobjekt, som indeholder to forskellige elementer af data, nemlig vertices og edges. der er 7641 vertices i vores objekt og 42967 edges. Hver af disse elementer kan have forskellige attributes (se + attr:) Som I kan se har vi to attributes name (v/c) og weight (e/n). (v/c) ved name betyder at det er en attribute til vores vertices og at det er en character vektor (det er en vektor med navne). (e/n) ved weight betyder at det er en attribute til vores edges og at det er en numerisk vektor (en vektor med tal, der indikerer styrken af forbindelsen)  Hvis vi gerne vil tilgå vertex attrubutes i vores grafobjekt skal vi bruge funktionen V() fra igraph efterfulgt af $ og navnet på den specifikke attribute her altså $name. Lad os se de første 20 navne.\n\nV(g_ind)$name %&gt;% head(20)\n\n [1] \"A. Jørgensen 69797\"                  \"Aage Lauritzen 71670\"               \n [3] \"Adam Carl Moltke-Huitfeldt 38972\"    \"Adam Paul Kybird 20002\"             \n [5] \"Adèle Stærkær de la Motte 57286\"     \"Ahmed Jahoor 64777\"                 \n [7] \"Alex Christian Pabst Pichardt 27234\" \"Alex Ostersen 19728\"                \n [9] \"Alexander Gamborg 69611\"             \"Alfred Hansen 70694\"                \n[11] \"Alice Schou Nørgaard 25900\"          \"Allan Buch 22800\"                   \n[13] \"Allan Christiansen 57789\"            \"Allan Gammelgård 64146\"             \n[15] \"Allan Kjær Ringe 69363\"              \"Allan Nielsen 19195\"                \n[17] \"Allan Nordahl 64147\"                 \"Allan Pedersen 59539\"               \n[19] \"Allan Smærup 68382\"                  \"Allan Staub Jensen 57965\"           \n\n\nHvis vi gerne vil tilgå edge attributes i vores grafobjekt skal vi bruge funktionen E() fra igraph efterfulgt af $ og navnet på den specifikke attribute her altså $weight. Lad os se de første 20 vægte og derefter et table() over fordelingen.\n\nE(g_ind)$weight %&gt;% head(20)\n\n [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n\nE(g_ind)$weight %&gt;% table()\n\n.\n    1     2     3     4     5     6     7 \n52063  1387   140    26    17     1     2 \n\n\nDer er altså mange, der kender hinanden fra en organisation, nogle kender hinanden fra to og ganske ganske få fra tre eller flere.\nvi kan også lave et graf-objekt for \\(organisation \\times organisation\\)-matricen:\n\ng_org &lt;- den_corp_org %&gt;% graph_from_adjacency_matrix(mode = \"undirected\", weighted = TRUE, diag = FALSE)\n\nlad os igen lige se vertex navne og edge vægte:\n\nV(g_org)$name %&gt;% head(20)\n\n [1] \"'ROSENHOLMFONDEN' 21165190\"                                                \n [2] \"[S] ADAMSHØJ GODS A/S 28970838\"                                            \n [3] \"[S] Bornholms Energi og Forsyning A/S 34722293\"                            \n [4] \"[S] BRØDR. EWERS A/S 45484815\"                                             \n [5] \"[S] DANOIL EXPLORATION A/S 10608147\"                                       \n [6] \"[S] EJENDOMS- OG FINANSIERINGSFONDEN FOR NORDJYLLANDS VIDENPARK 12751931\"  \n [7] \"[S] F. SALLING HOLDING A/S 41940115\"                                       \n [8] \"[S] HALBERG HOTELS A/S 82550712\"                                           \n [9] \"[S] LØGISMOSE A/S 21924679\"                                                \n[10] \"[S] MUP 2021 Holding A/S 42683906\"                                         \n[11] \"[S] MWG ManCo ApS 43318489\"                                                \n[12] \"[S] NLM A/S 44506289\"                                                      \n[13] \"[S] PENSIONSKASSEN FOR SUNDHEDSFAGLIGE 71973514\"                           \n[14] \"§ 6 Udvalget for Erhvervsfiskeri 25935\"                                    \n[15] \"§ 6a Udvalget for Muslingeproduktion 25941\"                                \n[16] \"§ 7 Udvalget for Rekreativt Fiskeri, Ferskvandsfiskeri og Fiskepleje 27523\"\n[17] \"§5 EU-fiskeriudvalget 27310\"                                               \n[18] \"15.JUNI FONDEN 15232102\"                                                   \n[19] \"2030-panelet (Medlemmer) 27048\"                                            \n[20] \"2030beyond 41504684\"                                                       \n\nE(g_org)$weight %&gt;% head(20)\n\n [1] 1 1 1 1 1 1 2 4 2 4 2 1 1 1 1 1 2 2 2 2\n\nE(g_org)$weight %&gt;% table()\n\n.\n   1    2    3    4    5    6    7    8    9   10   11   12   14   29 \n6131  428   90   35   27   12    4    3    2    4    2    1    1    1 \n\n\nHovedparten forbindelserne mellem organisationer skyldes altså ét overlappende medlem, nogle skyldes to og ganske få skyldes mere end to overlappende medlemmer (en enkelt forbindelse skyldes hele 17 fælles medlemmer)"
  },
  {
    "objectID": "session1.html#bipartite-netværk",
    "href": "session1.html#bipartite-netværk",
    "title": "Introduktion til netværksanalyse i R",
    "section": "(Bipartite) netværk",
    "text": "(Bipartite) netværk\nEndelig kan vi faktisk også lave et graf-objekt ud fra den oprindelige \\(individ \\times organisation\\) biadjacency matrice\ntil det bruges funktionen:\n\ngraph_from_biadjacency_matrix()\n\n\ng_bi &lt;- den_corp_bi %&gt;% graph_from_biadjacency_matrix()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Øvelsesplan og -introduktion",
    "section": "",
    "text": "Undervisere:\nLasse Folke Henriksen, IOA: Office hours mandag 10.00-11.20 (efter aftale)\nChristoph Houman Ellersgaard, IOA: Office hours mandag 9.00-10.20 (efter aftale)\nJacob Aagaard Lunding, IOA: Office hours fredag 13.40 - 15.00 (efter aftale)\nKursets formål\nKurset introducerer til virksomhedsstrategi i et netværksperspektiv. Virksomheder og deres medarbejdere er afhængige af deres omverden og en helt central måde er at knytte an til omverdenen gennem netværk af forskellig art. Virksomheder konkurrerer og samarbejder med andre organisationer via netværk, som bl.a. giver dem adgang til ressourcer, som de er afhængige af. Kurset udstyrer de studerende med redskaber fra netværksanalyse til at forstå hvordan interne såvel som eksterne netværk indvirker på virksomhedens strategiske processer. \nKurset har tre elementer. Første del giver en introduktion til forskellige teorier om ’virksomhedsstrategi i netværksperspektiv’ og eksemplificerer teorierne gennem brug af cases. Anden del indfører de studerende i metodiske redskaber fra netværksanalysen. Tredje del har fokus på anvendelse af netværksanalyse på konkrete cases og giver de studerende mulighed for at lave en konkret netværksanalyse af et intra- eller inter-organisatorisk netværk som vil være grundlag for eksamensopgaven. Forbindelsen mellem teori og metode i konkrete caseanalyser har prioritet ligesom de praktisk-strategiske implikationer af virksomhedsnetværk løbende vil blive diskuteret gennem kurset.\nØvelserne\n\n\n\nUge(r):\nHold\nTid\nLokale\n\n\n\n\n6, 8-12\nXB\nFredag 8:00 - 9:40\nDH.V.1.23\n\n\n8\nXB\nTorsdag 8:00 - 9:40\nDH.V.1.23\n\n\n6, 8-12\nXC\nFredag 9:50 - 11.30\nDH.V.1.23\n\n\n8\nXC\nTorsdag 9:50 - 11:30\nDH.V.1.23\n\n\n6, 8-9, 11-12\nXA\nFredag 12:35 - 14.15\nDH.V.1.23\n\n\n8\nXA\nTorsdag 12:35 - 14:15\nDH.V.1.23\n\n\n10\nXA\nFredag 11:40 - 13.20\nDH.V.0.30\n\n\n\nOver de næste 7 uger bliver I alle sammen kompetente brugere af programmeringssproget R og programmet RStudio, som er en slags kode-editor, der gør det nemmere at skrive, teste og køre kode. Med de kompetencer vil I ikke bare få en indsigt i tidens data science. I øvelserne kommer i også til at træne og udvikle jeres hand-on skills i kodning og avanceret computerbrug.\nI løbet af øvelserne skal vi arbejde med at indsamle, behandle og visualiserer relationelle data (i denne sammenhæng, data der kan studeres som netværk). Det er forhåbentlig nogle egenskaber, I vil kunne drage nytte af i jeres fremtidige studier og arbejdsliv.\nSom med så meget andet nyt vil de første par uger måske virke frustrerende for nogle. Programmeringstilgangen til databehandling (i modsætning til peg-og-klik-programmer) er måske ny for jer. Frustrationen er naturlig og forventet(!). Den bedste vej igennem er at møde op til øvelserne, hvor det også er muligt at stille spørgsmål og få konkret hjælp. Tålmodighed er desuden en dyd i denne sammenhæng. Selvom læringskurven kan være stejl, vil I efter et par uger allerede være mere fortrolige med at læse og skrive R kode.\nUnder fanen Install and setup R finder I en kommenteret guide til at installere den seneste version af R (4.5.2 (2025-10-31)) and Rstudio (2026.01.0-392).\n\n\n\n\n\n\nNote\n\n\n\nDet er vigtigt at I har disse versioner installeret på jeres computere, når vi starter, da nogle af de funktioner og pakker vi skal bruge til netværks-analyse kun virker i disse.\n\n\nVi ses til øvelserne!!\nJacob"
  },
  {
    "objectID": "session7.html",
    "href": "session7.html",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "",
    "text": "I denne session skal vi se på visualiering af netværk med ggraph-pakken: “En grafisk grammatik for relationel data”, som bygger oven på ggplot2.\n\n\nBegge dele følger den samme underliggende visualiseringsfilosofi/-grammatik.\n\nMan initialiserer et plot (et underliggende koordinatsystem) og bringer et datasæt i spil\nMan tilføjer lag (geom_*-funktioner), som definerer hvordan data skal repræsenteres.\n\nI ggraph() finder der to grupper af lag for hhv. edges og noder\n\ngeom_edge_*\ngeom_node_*\n\n\nJusterer scaler (for akser, størrelser, farver, gennemsigitighed, former osv.) (scale_*-funktioner)\nÆndrer på akse og legends forklaringer med guides() -funktionen, kombineret med fx. guide_legend() og som tillader os at ændre på hvordan en legend ser ud eller guide_axis() som tillader os at ændre på hvordan en akse ser ud. I begge tilfælde kan vi gøre brug af forskellige theme-objekter: fx legend.position eller legend.text kombineret med et theme_element som fx element_text()\nTilføjer prædifinerede temaer med theme_*-funktioner for hele plottet.\n\nDe forskellige muligheder i ggplot kan findes her og det samme for ggraph her\nLad os komme igang."
  },
  {
    "objectID": "session7.html#subset-data",
    "href": "session7.html#subset-data",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Subset data",
    "text": "Subset data\nOg udvælger en række tags, der tilsammen udgør finansverdenen i den17\n\nfinans_tags &lt;- c(\"Finance\", \"FINA\", \"Banks\", \"Pensions\", \"Insurance\", \"Venture- og kapitalfonde\")\n\nherfra har vi to muligheder.\n1) Enten subsetter vi den til alle positioner, der har et af de pågældende tags:\n\nden_finans1  &lt;- has.tags(den, tags = finans_tags, result = \"den\", mode = \"or\")\n\n                         Matched positions\nFinance                               2266\nFINA                                   692\nBanks                                  899\nPensions                               454\nInsurance                              584\nVenture- og kapitalfonde               130\n\n \n\nhead(den_finans1, 10)\n\n# A tibble: 10 × 10\n   name   affiliation role  gender tags  sector type  cvr_person cvr_affiliation\n   &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;           &lt;dbl&gt;\n 1 Asger… A/S DANSK … Exec… Men    Corp… Corpo… Virk… 4003993896        73314712\n 2 Hans … A/S DANSK … Vice… Men    Corp… Corpo… Virk… 4004141577        73314712\n 3 Lars … A/S DANSK … Memb… Men    Corp… Corpo… Virk… 4003896224        73314712\n 4 Micha… A/S DANSK … Memb… Men    Corp… Corpo… Virk… 4004121861        73314712\n 5 Thork… A/S DANSK … Chai… Men    Corp… Corpo… Virk… 4004010529        73314712\n 6 Gille… ALD Automo… Memb… Men    Corp… Corpo… Virk… 4006419783        87573613\n 7 Guill… ALD Automo… Chie… Men    Corp… Corpo… Virk… 4004174889        87573613\n 8 Micha… ALD Automo… Memb… Men    Corp… Corpo… Virk… 4004256917        87573613\n 9 Tim T… ALD Automo… Chai… Men    Corp… Corpo… Virk… 4004038684        87573613\n10 Asger… Alm. Brand  Othe… Men    Corp… Corpo… Virk… 4000077224        77333517\n# ℹ 1 more variable: description &lt;chr&gt;\n\n\n2) Eller også vælger vi at få en vector med navnene på alle de affiliations, der har et af de pågældende tags:\n\nfinans_affils  &lt;- has.tags(den, tags = finans_tags, result = \"affil\", mode = \"or\")\n\n                         Matched positions\nFinance                               2266\nFINA                                   692\nBanks                                  899\nPensions                               454\nInsurance                              584\nVenture- og kapitalfonde               130\n\n \n\nhead(finans_affils, 10)\n\n [1] \"A/S DANSK ERHVERVSINVESTERING\"                                \n [2] \"ALD Automotive\"                                               \n [3] \"Alm. Brand\"                                                   \n [4] \"Alm. brand - Repraesentantskab (Medlemmer)\"                   \n [5] \"Alpha Holding\"                                                \n [6] \"ALTOR EQUITY PARTNERS A/S\"                                    \n [7] \"Ankenaevnet for Forsikring (Medlemmer)\"                       \n [8] \"AP Pension\"                                                   \n [9] \"Arbejdernes Landsbank\"                                        \n[10] \"Arbejdsmarkedets Erhvervssygdomssikring (AES) (Departementet)\"\n\n\nGør vi dét, har vi nemlig mulighed for også at udvælge særlige ting, der ikke har et af de pågældende tags. Det kunne fx være at vi gerne vil have alle VL-grupper med også. Vi laver derfor en vektor med navnene på alle tværgående netværksgrupper, hvor der sidder et individ, som har et finans tag:\n\nfinans_ind &lt;- has.tags(den, tags = finans_tags, result = \"name\", mode = \"or\")\n\n                         Matched positions\nFinance                               2266\nFINA                                   692\nBanks                                  899\nPensions                               454\nInsurance                              584\nVenture- og kapitalfonde               130\n\n \n\nhead(finans_ind)\n\n[1] \"Asger Ib Mardahl-Hansen\" \"Hans Ole Jensen\"        \n[3] \"Lars Groenborg Eskesen\"  \"Michael Noergaard\"      \n[5] \"Thorkild Engell Jensen\"  \"Gilles Jean-Noël Momper\"\n\n\n\nden %&gt;% count(type)\n\n# A tibble: 10 × 2\n   type                     n\n   &lt;chr&gt;                &lt;int&gt;\n 1 Begivenhed            2086\n 2 Folketing              241\n 3 Fond (CVR)            1783\n 4 Kommission             772\n 5 Netvaerk (VL-gruppe)  4318\n 6 Organisation         14819\n 7 Snowball                11\n 8 Stat                 10419\n 9 Virksomhed (CVR)      9722\n10 &lt;NA&gt;                 12678\n\nvl_grupper &lt;- den %&gt;% \n  filter(type == \"Netvaerk (VL-gruppe)\" & name %in% finans_ind) %&gt;%  \n  distinct(affiliation) %&gt;% \n  pull(affiliation)\n\nNår vi har de to vektorer med affiliation-navne kan vi bruge dem til at subsette data med:\n\nden_finans2 &lt;- den %&gt;% filter(affiliation %in% c(finans_affils, vl_grupper))\ndim(den_finans2)\n\n[1] 5684   10"
  },
  {
    "objectID": "session7.html#individ-x-affiliation-matrice",
    "href": "session7.html#individ-x-affiliation-matrice",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "individ x affiliation matrice:",
    "text": "individ x affiliation matrice:\n\nbi_adj &lt;- xtabs(den_finans2, formula = ~name + affiliation, sparse = T)\n\nFra individ x affiliation matricen, kan vi lave to matricer (det er vigtigt at Matrix pakken er læst ind her - library(Matrix))"
  },
  {
    "objectID": "session7.html#individ-x-individ-matricen",
    "href": "session7.html#individ-x-individ-matricen",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Individ x individ matricen:",
    "text": "Individ x individ matricen:\n\nadj_ind &lt;- bi_adj %*% t(bi_adj)"
  },
  {
    "objectID": "session7.html#affiliation-x-affiliation-matricen",
    "href": "session7.html#affiliation-x-affiliation-matricen",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "affiliation x affiliation matricen:",
    "text": "affiliation x affiliation matricen:\n\nadj_affil &lt;- t(bi_adj) %*% bi_adj"
  },
  {
    "objectID": "session7.html#two-mode-bipartite",
    "href": "session7.html#two-mode-bipartite",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "two-mode (bipartite)",
    "text": "two-mode (bipartite)\nfra individ x affiliation matricen (bi_adj) laver vi et bipartite/two-mode netværksobjekt\n\nnet_twomode &lt;- graph_from_biadjacency_matrix(bi_adj, directed = FALSE, multiple = FALSE) %&gt;% simplify()\nnet_twomode\n\nIGRAPH 1d54cad UN-B 5147 5684 -- \n+ attr: type (v/l), name (v/c)\n+ edges from 1d54cad (vertex names):\n[1] Aage Almtoft            --Middelfart Sparekasse                                                        \n[2] Aage B. Andersen        --Foreningen OEstifterne - Repraesentantskab (Medlemmer af delegeretforsamling)\n[3] AAge Dragsted           --VL gruppe 35 – Aarhus                                                        \n[4] AAke Per-Urban Bäckström--Danske Bank                                                                  \n[5] Aase Hoeck              --Dansk Aktionaerforening (repraesentantskab)                                  \n+ ... omitted several edges"
  },
  {
    "objectID": "session7.html#individ-netværk",
    "href": "session7.html#individ-netværk",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Individ-netværk",
    "text": "Individ-netværk\nfra individ x individ matricen (adj_ind) laver vi et one-mode netværk for individer\n\nnet_ind &lt;- graph_from_adjacency_matrix(adj_ind, mode = \"undirected\", diag = FALSE) %&gt;% simplify()\nnet_ind\n\nIGRAPH b63020d UN-- 4816 89658 -- \n+ attr: name (v/c)\n+ edges from b63020d (vertex names):\n [1] Aage Almtoft    --Allan Buch             \n [2] Aage Almtoft    --Bettina Joergensen     \n [3] Aage Almtoft    --Bo Skovby Rosendahl    \n [4] Aage Almtoft    --Bo Smith 4493          \n [5] Aage Almtoft    --Claus Nielsen 50129    \n [6] Aage Almtoft    --Jan Melgaard           \n [7] Aage Almtoft    --Martin Noerholm Baltser\n [8] Aage Almtoft    --Michael Frandsen       \n+ ... omitted several edges"
  },
  {
    "objectID": "session7.html#affiliation-netværk",
    "href": "session7.html#affiliation-netværk",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Affiliation-netværk",
    "text": "Affiliation-netværk\n\nnet_affil &lt;- graph_from_adjacency_matrix(adj_affil, mode = \"undirected\", diag = FALSE) %&gt;% simplify()\nnet_affil\n\nIGRAPH c818219 UN-- 331 984 -- \n+ attr: name (v/c)\n+ edges from c818219 (vertex names):\n[1] A/S DANSK ERHVERVSINVESTERING--FAGBEVAEGELSENS ERHVERVSINVESTERING A/S (Bestyrelse)                   \n[2] A/S DANSK ERHVERVSINVESTERING--VL gruppe 4 - Koebenhavn                                               \n[3] Alm. Brand                   --Alm. brand - Repraesentantskab (Medlemmer)                             \n[4] Alm. Brand                   --Byggesocietetet (Koebenhavnsudvalget )                                 \n[5] Alm. Brand                   --DFL - Danske Forsikringsfunktionaerers Landsforening (Hovedbestyrelsen)\n+ ... omitted several edges"
  },
  {
    "objectID": "session7.html#initierer-af-et-plot-med-ggraph-funktionen",
    "href": "session7.html#initierer-af-et-plot-med-ggraph-funktionen",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "1) Initierer af et plot med ggraph()-funktionen",
    "text": "1) Initierer af et plot med ggraph()-funktionen\nFørst initierer vi et plot med ggraph() funktionen og et netværksobjekt:\nDet giver os et øjensynligt tomt plot. Funktionen har dog allerede defineret ét lag, nemlig layout-laget. Da vi ikke har specificeret noget layout har ggraph brugt default layoutet stress\n\np &lt;- ggraph(net_affil_l)\n\nUsing \"stress\" as default layout\n\np"
  },
  {
    "objectID": "session7.html#tegn-edges",
    "href": "session7.html#tegn-edges",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "2) Tegn edges",
    "text": "2) Tegn edges\ndet næste vi tilføjer er oftest laget med edges. Fordi vi lægger lag-på-lag, er det vigtig hvilken rækkefølge vi gør det i. Visuelt giver det mest mening at lægge edges på først, så de ikke ligger oven på noderne:\nNår vi tilføjer lag i ggraph bruger vi geom’er som i ggplot. Der er som nævnt et specifikt sæt af geom’er for edges, geom_edge_*. Oftest vil vi tegne dem som en ‘streg’ og bruger derfor geom_edge_link0 :\n\np + geom_edge_link0()\n\n\n\n\n\n\n\n\nda vi har et relativt stort og dense netværk (der er 984 edges), vil vi måske gerne gøre dem mindre visuelt dominerende. I geom_edge_* funktionerne kan vi ændre på en række parametre:\n\nwidth (tykkelsen på linjerne)\n\nsom går fra 0 (ingen tykkelse) til uendeligt tykke.\n\ncolor (farven på linjerne)\n\nkan være en hex farvekode, fx. #f50e0a (en variant af rød) eller en navngiven farve. (brug evt. funktionen edit(colors()) til at se de navngivne farver i R)\n\nalpha (linjernes ‘gennemsigtighed’)\n\nsom går fra 0 til 1 (0 = helt gennemsigtige, 1 = helt optegnede)\n\n\nLad os prøve at sætte en farve, en variant af grå, og en tykkelse, 0.3, og en gennemsigtighed, 0.3.\n\np &lt;- p + geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3)\np"
  },
  {
    "objectID": "session7.html#tegn-noder",
    "href": "session7.html#tegn-noder",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "3) Tegn noder",
    "text": "3) Tegn noder\nNu vil vi gerne tilføje laget med noder (i dette tilfælde virksomheder).\nDer også et specifikt sæt af geom’er for noder, geom_node_*. Oftest vil vi tegne dem som et ‘punkt’, så vi bruger geom_node_point():\n\np + geom_node_point()\n\n\n\n\n\n\n\n\nI geom_node_* funktionerne kan vi også ændre på en række parametre:\n\nsize (størrelsen på punkterne)\n\nsom går fra 0 (ingen størrelse) til uendelig størrelse.\n\nshape (formen på punktet)\n\n\n\n\n\n\n\ncolor (farven på punktet/ eller på punktets omkreds - hvis man vælger en af de ‘røde’ shapes fra figuren og sætter en anden fill)\n\nkan være en hex farvekode, fx. #f50e0a (en variant af rød) eller en navngiven farve. (brug evt. funktionen edit(colors()) til at se de navngivne farver i R)\n\nfill (styrer for de røde shapes farven på punktet, mens color så styrer omkredsen)\nalpha (linjernes ‘gennemsigtighed’)\n\nsom går fra 0 til 1 (0 = helt gennemsigtige, 1 = helt optegnede)\n\n\nLad os sætte en størrelse på 3, en rund shape med farve, nr. 21, en alpha på 0.75, en omkredsfarve (color), sort, og en fill, salmon2.\n\np &lt;- p + geom_node_point(size = 3, shape = 21, color = \"steelblue\", fill = \"salmon2\",alpha = 0.75)\np"
  },
  {
    "objectID": "session7.html#netværkstema-baggrund",
    "href": "session7.html#netværkstema-baggrund",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "4) Netværkstema (baggrund):",
    "text": "4) Netværkstema (baggrund):\nNu har vi næsten lavet vores simple plot. Der er dog noget med den grå baggrund…. I ggraph ligger der et standard theme til netværksvisualiseringer, theme_graph(), lad os tilføje det.\n\np &lt;- p + theme_graph()\np"
  },
  {
    "objectID": "session7.html#titel-mv.",
    "href": "session7.html#titel-mv.",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "5) Titel mv.",
    "text": "5) Titel mv.\nSom det sidte vil vi måske gerne tilføje en forklarende titel til vores visualisering.\n\np + ggtitle(\"Virksomhedsnetværket i finanssektoren\")\n\n\n\n\n\n\n\n\nog måske også en undertitel. Det kunne være antallet af noder (eller noget helt andet). Vi vi gerne vil ‘blande’ et tal ind uden at skrive det selv. Fx så vi kan opdatere analysen og køre koden uden at ændre plotkoden, kan vi bruge paste0() til at sætte tekst og outputtet fra en funktion sammen: paste0(\"n = \", vcount(net_affil_l)) vil sætte “n =” sammen med outputtet fra vcount() som er antallet af noder.\nVi kan også tilføje en caption i hjørnet med labs(caption =) faktisk kan man også bestemme title og subtitle med labs.\n\n#Enten \np + ggtitle(\"Virksomhedsnetværket i finanssektoren\", subtitle = paste0(\"n = \", vcount(net_affil_l))) + labs(caption = \"datakilde: Danish Elitenetwork 2017\")\n\n\n\n\n\n\n\n#Eller det hele med labs\np &lt;- p + labs(title = \"Virksomhedsnetværket i finanssektoren\", \n              subtitle = paste0(\"n = \", vcount(net_affil_l)), \n              caption = \"datakilde: Danish Elitenetwork 2017\")\n\nOpsummerende kan vi gøre det hele på en gang i stedet:\n\np &lt;- ggraph(net_affil_l) + \n  geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3) +\n  geom_node_point(size = 3, shape = 21, color = \"steelblue\", \n                  fill = \"salmon2\",alpha = 0.75) + \n  theme_graph() +\n  labs(title = \"Virksomhedsnetværket i finanssektoren\", \n              subtitle = paste0(\"n = \", vcount(net_affil_l)), \n              caption = \"datakilde: Danish Elitenetwork 2017\")\n\nUsing \"stress\" as default layout\n\np"
  },
  {
    "objectID": "session7.html#gem-plot-som-en-billede-fil",
    "href": "session7.html#gem-plot-som-en-billede-fil",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "6) Gem plot som en billede fil",
    "text": "6) Gem plot som en billede fil\nggplot2 har en funktion, der hedder ggsave() som gemmer det aktive plot (eller et bestemt plot objekt) til en sti vi vælger og et filformat vi bestemmer. Hvis den mappe vi ‘sender’ filen til ikke findes, kan man bruge create.dir = TRUE, så laver R mappen.\nJeg vil gerne gemme til min output mappe (der må gerne stå create.dir = TRUE, også selvom den allerede findes). Og det skal være en png fil.\nAndre relevante options er height = og width = . Dem kan I skrue på hvis plottet bliver enten for stort elle for lille i den fil i gemmer.\n\nggsave(filename = \"output/simpelt_plot.png\", plot = p, height = 6, width = 6, create.dir = TRUE)"
  },
  {
    "objectID": "session7.html#farve",
    "href": "session7.html#farve",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "1) Farve",
    "text": "1) Farve\nHvis man gerne vil lade farven følge værdierne på en variabel, skal man bruge mapping = aes() i geom_* funktionen.\nHvis vi genbruger plot koden for edges, theme og title fra før (men undlader nodes)\n\np &lt;- ggraph(net_affil_l) + \n  geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3)  + \n  theme_graph() +\n  labs(title = \"Virksomhedsnetværket i finanssektoren\", \n              subtitle = paste0(\"n = \", vcount(net_affil_l)), \n              caption = \"datakilde: Danish Elitenetwork 2017\")\n\nUsing \"stress\" as default layout\n\n\nog nu tilføjer en anden variant af geom_node_point() laget.\nVi kan lade size, shape, alpha og color forblive uden for vores mapping, dvs. som konstante værdier. Hvis vi mapper sector henover fill, farver vi indholdet i cirklerne efter sektor\n\np + geom_node_point(size = 3, shape = 21, alpha = 0.75, color = \"grey15\",\n                    mapping = aes(fill = sector))\n\n\n\n\n\n\n\n\nvi kan også mappe sector henover color og lade både indhold og omkreds være styret af sector.\n\np + geom_node_point(size = 3, shape = 21, alpha = 0.75,\n                    mapping = aes(color = sector, fill = sector))\n\n\n\n\n\n\n\n\nEller samlet :\n\np &lt;- ggraph(net_affil_l) + \n  geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3) +\n  geom_node_point(size = 3, shape = 21, alpha = 0.75,\n                  mapping = aes(color = sector, fill = sector)) + \n  theme_graph() +\n  labs(title = \"Virksomhedsnetværket i finanssektoren\", \n              subtitle = paste0(\"n = \", vcount(net_affil_l)), \n              caption = \"datakilde: Danish Elitenetwork 2017\")\n\nUsing \"stress\" as default layout\n\np\n\n\n\n\n\n\n\n\n\n1.1 Farveskalaer for ikke kontinuerte variable\nLad os nu sige vi vælge en anden farveskala: Til det skal vi have fat i et scales_* element.\nscale_color_* og scale_fill_* er de to scale elementer vi skal bruge for at ændre farveskalaen på color og fill:\nmed scale_*_manual() kan man sætte farverne selv.\nmed scale_*_brewer() kan man bruge værdierne fra en defineret palette\nkør fx RColorBrewer::display.brewer.all()\nLad os prøve en farveskala fra brewer\n\n# enten\np + scale_fill_brewer(palette = \"Set1\") + \n  scale_color_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n# eller i en linje\np + scale_color_brewer(palette = \"Set1\", aesthetics = c(\"color\", \"fill\"))\n\n\n\n\n\n\n\n\nVi kan også konstruere vores egen farve skale:\n\ncolors &lt;- c(\"Commissions\" = \"deeppink4\", \"Corporations\" = \"steelblue1\", \"Family\" = \"forestgreen\", \"Foundations\" =\"steelblue4\", \"NGO\" = \"salmon1\" , \"State\" = \"magenta\", \"Unknown\"= \"grey25\", \"VL_networks\" = \"brown\")\n\nog bruge den med scale_*_manual()\n\np &lt;- p + scale_color_manual(values = colors, aesthetics = c(\"color\", \"fill\")) \np"
  },
  {
    "objectID": "session7.html#ændrer-legends",
    "href": "session7.html#ændrer-legends",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "2) Ændrer legends",
    "text": "2) Ændrer legends\nSom udgangspunkt får vores legend navn efter den variabel vi mapper. Det kan jo godt vi gerne vil ændre det:\nHer kan vi bruge guides() funktionen + guide_legend()\n\np &lt;- p + guides(fill = guide_legend(title = \"Sektor\"), \n           color = guide_legend(title = \"Sektor\"))\np\n\n\n\n\n\n\n\n\nVi kan også ændre på legends placering: (left, bottom, right (default))\n\np + theme(legend.position = \"bottom\")\n\n\n\n\n\n\n\n\n\n2.1 legend-label rækkefølge og label-værdier\nHvis vi gerne vil ændre rækkefølgen af værdierne på vores legend kan vi definere det i scale_*_* elementet for både color og fill samtidigt.\n\np + scale_color_manual(values = colors, breaks = c(\"Family\", \"VL_networks\", \"Corporations\", \"Foundations\", \"State\", \"Commissions\", \"NGO\", \"Unknown\"), aesthetics = c(\"color\", \"fill\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\nVi kan også ændre navnene:\n\np &lt;- p + scale_color_manual(values = colors, breaks = c(\"Family\", \"VL_networks\", \"Corporations\", \"Foundations\", \"State\", \"Commissions\", \"NGO\", \"Unknown\"), \n                       labels = c(\"Familie\", \"VL-grupper\", \"Virksomheder\", \"Fonde\", \"Staten\", \"Kommissioner\", \"NGOer\", \"Ukendt\"), \n                       aesthetics = c(\"color\", \"fill\"))\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\np"
  },
  {
    "objectID": "session7.html#size-efter-et-kontinuert-mål-fx.-betweenness",
    "href": "session7.html#size-efter-et-kontinuert-mål-fx.-betweenness",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "1) Size efter et kontinuert mål (fx. betweenness)",
    "text": "1) Size efter et kontinuert mål (fx. betweenness)\nHer sætter vi fill uden for vores mapping og giver den en konstant værdi, og sætter i stedet size ind i mapping’en og lader den følge betweennes værdien\n\np &lt;- ggraph(net_affil_l) + \n  geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3) +\n  geom_node_point(shape = 21, alpha = 0.75, fill = \"salmon2\", \n                  mapping = aes(size = bet)) + \n  theme_graph() +\n  labs(title = \"Virksomhedsnetværket i finanssektoren\",  \n       subtitle = paste0(\"n = \", vcount(net_affil_l)), \n       caption = \"datakilde: Danish Elitenetwork 2017\")\n\nUsing \"stress\" as default layout\n\np\n\n\n\n\n\n\n\n\nVi kan også lade størrelse være styret af betweenness og stadige have farve efter sector:\nmed scale_color_* vælger vi farveskala (her kan vi også sætte legendnavnet med name =)\nmed scale_size_* vælger vi størrelsesskalaen for punkterne. Da betweenness er et kontinuert mål, bruger vi size_scale_continous(), hvor vi kan sætte en range = c(min, max)\n\np &lt;- ggraph(net_affil_l) + \n  geom_edge_link0(color = \"grey70\", width = 0.3, alpha = 0.3) +\n  geom_node_point(shape = 21, alpha = 0.75,\n                  mapping = aes(size = bet, fill = sector)) + \n  scale_fill_brewer(name = \"Sektor\", palette = \"Set1\") +\n  scale_size_continuous(name = \"Betwenness centrality\", range = c(1,8)) + \n  theme_graph() +\n  labs(title = \"Virksomhedsnetværket i finanssektoren\", \n              subtitle = paste0(\"n = \", vcount(net_affil_l)), \n              caption = \"datakilde: Danish Elitenetwork 2017\")\n\nUsing \"stress\" as default layout\n\np"
  },
  {
    "objectID": "session7.html#labels-på-et-plot-geom_node_label-og-filter",
    "href": "session7.html#labels-på-et-plot-geom_node_label-og-filter",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Labels på et plot…! geom_node_label() og filter =",
    "text": "Labels på et plot…! geom_node_label() og filter =\nVi har sjældent brug for at sætte label på alle noder, men vi vil måske gerne sætte labels på de 3 mest centrale noder? Eller på et udvalg af noder. Til det kan vi bruge geom’et geom_node_label() og ‘mappe’ vertex attribute’en name hen over koordinaterne.\nFordi vi ikke vil plotte alle label, bruger vi parameteret filter i aes():\n\np + geom_node_label(mapping = aes(filter = bet_rnk&lt;=3, label = name))\n\n\n\n\n\n\n\n\nHvis labels ligger oven i hinanden kan det være nyttigt at tilføje parameteret repel = TRUE.\n\np + geom_node_label(mapping = aes(filter = bet_rnk&lt;=3, label = name), repel = T)\n\n\n\n\n\n\n\n\nMåske er mine labels for store? Vi kan ændre på størrelsen og også på deres gennemsigtighed (alpha) samt på text typen family så den passer til resten af plottet\n\np &lt;- p + geom_node_label(mapping = aes(filter = bet_rnk&lt;=3, label = name), size = 3, alpha = 0.8, family = \"serif\", repel = T) \np\n\n\n\n\n\n\n\n\ndet ser efterhånden meget godt ud… Måske er jeg ked af at størrelsen på cirklerne i min color legend er så små. Det kan jeg også justere på med guides() og guide_legend() :"
  },
  {
    "objectID": "session7.html#override-legend-aesthetics",
    "href": "session7.html#override-legend-aesthetics",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Override legend aesthetics…",
    "text": "Override legend aesthetics…\n\np &lt;- p + guides(fill = guide_legend(override.aes = list(size = 4)))\np\n\n\n\n\n\n\n\n\nLad os gemme det plot også :\n\nggsave(filename = \"output/betweennescentralitet_plot.png\", plot = p, height = 7, width = 9)\n\nStandard units på height og width er inches (in). Måske er det lettere for os at bruge cm.\n\nggsave(filename = \"output/betweennescentralitet_plot.png\", plot = p, height = 16, width = 20, units = \"cm\")\n\nKig på filen og juster størrelsen, så forholdet mellem plot og lærred (og tekst- og punktstørrelse mv.) ser fornuftigt ud."
  },
  {
    "objectID": "session7.html#korrelationen-mellem-to-forskellige-mål",
    "href": "session7.html#korrelationen-mellem-to-forskellige-mål",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Korrelationen mellem to forskellige mål",
    "text": "Korrelationen mellem to forskellige mål\nVi kan fx plotte korrelationen mellem betweenness og brokerage\n\nmetrics %&gt;% \nggplot() + \n  geom_point(aes(x = brokerage, y = betweenness, color=sector, size=degree)) + \n  #geom_label(aes(x = brokerage, y = closeness, label = name2)) +\n  scale_color_manual(values=colors) +\n  scale_x_continuous(breaks = seq(1,max(metrics$brokerage), 1), name = \"1/Burts constraint\") +\n  scale_y_continuous(name = \"Betweenness\") +\n  guides(color = guide_legend(override.aes = list(size = 4), title = \"Virksomhedstype\"),\n         size = guide_legend(title = \"Degree centralitet\")) +\n  theme_bw(base_family = \"serif\")"
  },
  {
    "objectID": "session7.html#et-mål-men-delt-op-på-en-variabel---facet_wrap",
    "href": "session7.html#et-mål-men-delt-op-på-en-variabel---facet_wrap",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "Et mål, men delt op på en variabel - facet_wrap()",
    "text": "Et mål, men delt op på en variabel - facet_wrap()\nDer er ikke ret mange noder i kategorierne Commissions og Unknown, så dem filterer vi lige fra her.\nVi kan nu prøve at se hvor stor en andel af noderne i de forskellige sektorer, der ligger hhv. højt og lavt på fx brogerage.\n\nmetrics %&gt;% filter(!sector %in% c(\"Commissions\", \"Unknown\")) %&gt;% \nggplot() + \n  geom_density(aes(x = brokerage, fill=sector)) + \n  labs(y='share') + \n  facet_wrap(~sector) + \n  scale_fill_manual(values=colors) + \n  guides(fill = \"none\") +\n  theme_minimal(base_family = \"serif\") + \n  theme(strip.text.x = element_text(size = 12, face = \"bold\"))"
  },
  {
    "objectID": "session7.html#en-masse-mål-i-forhold-til-hinanden",
    "href": "session7.html#en-masse-mål-i-forhold-til-hinanden",
    "title": "Finpudsning af analyse og visualisering af netværk",
    "section": "En masse mål i forhold til hinanden",
    "text": "En masse mål i forhold til hinanden\nHer kan I bruge min cor_plots funktion, husk at droppe variable i metrics der ikke er centralitetsvariable (her name og sector)\n\np_cor &lt;- cor_plots(metrics_table = metrics %&gt;% select(-name,-sector, -tags))\np_cor"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "Intro til R og Tidyverse",
    "section": "",
    "text": "Det følgende r-scripts er skrevet med afsæt i R version 4.5.2 (2025-10-31). Hvis I ikke allerede har installeret denne seneste version så følg guiden i Install and setup R\nDet er desuden en god ide at have downloadet zip-filen med r-projektet virkstrat_netvaerk her:\nDownload Data\neller fra kursets canvas-side.\nDen fil indeholder følgende filer og mapper:\n\n\n\nIndhold af zip-filen\n\n\n(og skal i øvrigt opdateres med filer, jeg løbende lægger op på Canvas):\nDownload zip-filen og pak den ud et fornuftigt sted på jeres harddisk (så I ved hvor I har den), det kunne fx. være i den mappe i har jeres andre studierelevante ting i, så som noter o.l.\nHvis I sørger for altid at åbne virkstrat_netvaerk.Rproj filen enten ved at dobbeltklikke på den, eller åbne den inde fra R-studio øverste højre hjørne (hvor den vil ligge som ‘recent projects’ hvis den har været åbnet før). Hvis ikke skal I finde den under open project… (hvor I ‘browser’ jer frem til der hvor filen ligger)."
  },
  {
    "objectID": "intro.html#tidyverse-grammatikken",
    "href": "intro.html#tidyverse-grammatikken",
    "title": "Intro til R og Tidyverse",
    "section": "Tidyverse-grammatikken",
    "text": "Tidyverse-grammatikken\n\nLæs data og assign ‘&lt;-’\nFørst indlæser vi noget data med read_csv(). I mappen data ligger et eksempeldatasæt med flyafgangstider i NYC 2013 (ja, hvorfor ikke).\nFilen ligger i “data-mappen” i vores R-projekt.\nDownload Data\n\n\n\n\n\n\nNote\n\n\n\nHvis I downloader datafilen (csv) her, så læg den i ‘data’-mappen i jeres Rprojekt-mappe\n\n\nVi giver read_csv() stien til filen “data/fligths.csv” (vi kan undlade alt foran data/ fordi vi er i et Rprojekt, som har et working directory. Dvs R ved hvor på computeren, vi befinder os). Hvis vi bare ‘kører’ koden får vi læst data ind, men ikke gemt i hukommelsen.\n\nread_csv(\"data/flights.csv\")\n\nNew names:\nRows: 336776 Columns: 20\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" chr\n(4): carrier, tailnum, origin, dest dbl (15): ...1, year, month, day, dep_time,\nsched_dep_time, dep_delay, arr_... dttm (1): time_hour\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -&gt; `...1`\n\n\n# A tibble: 336,776 × 20\n    ...1  year month   day dep_time sched_dep_time dep_delay arr_time\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1     1  2013     1     1      517            515         2      830\n 2     2  2013     1     1      533            529         4      850\n 3     3  2013     1     1      542            540         2      923\n 4     4  2013     1     1      544            545        -1     1004\n 5     5  2013     1     1      554            600        -6      812\n 6     6  2013     1     1      554            558        -4      740\n 7     7  2013     1     1      555            600        -5      913\n 8     8  2013     1     1      557            600        -3      709\n 9     9  2013     1     1      557            600        -3      838\n10    10  2013     1     1      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time &lt;dbl&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,\n#   flight &lt;dbl&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,\n#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nFor at ‘gemme’ vores data i hukommelsen bruger vi ‘&lt;-’ assign operatoren. Det betyder at vi læser data ind, men nu assigner det til et objekt, som vi kalder flights\n\nflights &lt;- read_csv(\"data/flights.csv\")\n\n\n\nDatabehandling med dplyr\ndplyr delen af Tidyverse består blandt andet af en lang række funktioner (verber) som udgør det centrale element i gramatikken. De ‘gør’ noget med vores objekter. Generalt er strukturen i en tidyverse kode altid: 1. et data-objekt 2. en række verber 3. et nyt ændret data-objet. En elegant måde at skrive kode på er at bruge den såkaldte pipe operator %&gt;%. Den tager så at sige dét, der står til venstre, og sender videre til dét, der står til højre. Man kan skrive ‘pipen’ eller bruge en genvejstast som i Windows er Control + Shift + M og i MacOS Cmd + Shift + M\n\nEt simpelt verbum er fx. head(), som viser de første rækker af vores data\n\nflights %&gt;% head()\n\n# A tibble: 6 × 20\n   ...1  year month   day dep_time sched_dep_time dep_delay arr_time\n  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n1     1  2013     1     1      517            515         2      830\n2     2  2013     1     1      533            529         4      850\n3     3  2013     1     1      542            540         2      923\n4     4  2013     1     1      544            545        -1     1004\n5     5  2013     1     1      554            600        -6      812\n6     6  2013     1     1      554            558        -4      740\n# ℹ 12 more variables: sched_arr_time &lt;dbl&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,\n#   flight &lt;dbl&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,\n#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\neller glimpse(), der viser hvilke typer af variable etc vores objekt indeholder og samtidig giver eksempler på værdierne:\n\nflights %&gt;% glimpse()\n\nRows: 336,776\nColumns: 20\n$ ...1           &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, …\n$ year           &lt;dbl&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       &lt;dbl&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time &lt;dbl&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       &lt;dbl&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time &lt;dbl&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        &lt;chr&gt; \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         &lt;dbl&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        &lt;chr&gt; \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         &lt;chr&gt; \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           &lt;chr&gt; \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n\n\nVi kan inddele de mest almindelige verber i tre grupper: nogle der gør noget i forhold til rækker, nogle der gør noget i forhold til kolonner og nogle der gør noget i forhold til grupper\n\nRække orienterede verber/funktioner\nLad os starte med en af de verber vi kommer til at bruge hele tiden, filter(). I forhold til måden at skrive kode på tager vi vores data.objekt flights og sender det videre %&gt;% til verbet filter(), som filtrer data baseret på de betingelser vi giver det. flights indeholder en variable der hedder dep_delay (hvor meget var en afgang forsinket). Lad os sige vi kun vil se på de afgange der er forsinket med mere &gt; end tre timer (180 min). Vi kunne også have brugt andre betingesler, fx. mindre end, &lt;, eller lig med == (husk at vi altid bruger dobbelt =, når der er tale om logiske operationer), eller ikke lig med !=.\n\nflights %&gt;% filter(dep_delay &gt; 180)\n\n# A tibble: 3,893 × 20\n    ...1  year month   day dep_time sched_dep_time dep_delay arr_time\n   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;\n 1   152  2013     1     1      848           1835       853     1001\n 2   650  2013     1     1     1815           1325       290     2120\n 3   674  2013     1     1     1842           1422       260     1958\n 4   747  2013     1     1     2006           1630       216     2230\n 5   802  2013     1     1     2115           1700       255     2330\n 6   816  2013     1     1     2205           1720       285       46\n 7   831  2013     1     1     2312           2000       192       21\n 8   835  2013     1     1     2343           1724       379      314\n 9  1243  2013     1     2     1244            900       224     1431\n10  1279  2013     1     2     1332            904       268     1616\n# ℹ 3,883 more rows\n# ℹ 12 more variables: sched_arr_time &lt;dbl&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,\n#   flight &lt;dbl&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,\n#   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;\n\n\nIgen vil vi gerne gemme det data der kommer ud. Lige nu har vi bare ‘vist’ det. Derfor assigner vi vores outcome til et nyt objekt fligths_delayed, som nu kun indeholder de rækker vi har bedt om, baseret på dep_delay:\n\nflights_delayed &lt;- flights %&gt;% filter(dep_delay &gt; 180)\n\nVi kan også basere vores filter på mere end en betingelse. I så fald bruger vi enten og & eller eller |, fx.\n\nflights_delayed &lt;- flights %&gt;% filter(dep_delay &gt; 60 & dep_delay &lt; 120)\n\nHvor vi reducerer vores data med flyafgange til alle fly der er mere end en time og mindre end to timer forsinket.\n\n\nKolonne orienterede funktioner/verber\nEn funktion vi kommer til at bruge meget, og som svarer til filter(), men gælder kolonnerne, er select(). Med select vælger vi de variable vi vil beholde. Lad os reducere vores data, så vi kun har afgangs- og ankomststed samt år, måned, dag og forsinkelse.\n\nflights_reduced &lt;- flights %&gt;% select(origin, dest, year, month, day, dep_delay)\nflights_reduced %&gt;% head()\n\n# A tibble: 6 × 6\n  origin dest   year month   day dep_delay\n  &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 EWR    IAH    2013     1     1         2\n2 LGA    IAH    2013     1     1         4\n3 JFK    MIA    2013     1     1         2\n4 JFK    BQN    2013     1     1        -1\n5 LGA    ATL    2013     1     1        -6\n6 EWR    ORD    2013     1     1        -4\n\n\nEn anden nyttig kolonne-funktion er rename(). Måske vil vi gerne kalde vores kolonner noget andet. I det her tilfælde kunne det være vi gerne ville have det på dansk. rename() fungerer på den måde at man skriver det nye navn og fortæller funktionen at det skal være lig med = det gamle navn. Bemærk at vi her ikke assigner vores output til noget objekt, vi ser bare de første par rækker, head(). Dvs. flights_reduced objektet forbliver uforandret\n\nflights_reduced %&gt;% rename(fra = origin, til = dest, år = year, måned = month, dag = day, forsinkelse = dep_delay) \n\n# A tibble: 336,776 × 6\n   fra   til      år måned   dag forsinkelse\n   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;\n 1 EWR   IAH    2013     1     1           2\n 2 LGA   IAH    2013     1     1           4\n 3 JFK   MIA    2013     1     1           2\n 4 JFK   BQN    2013     1     1          -1\n 5 LGA   ATL    2013     1     1          -6\n 6 EWR   ORD    2013     1     1          -4\n 7 EWR   FLL    2013     1     1          -5\n 8 LGA   IAD    2013     1     1          -3\n 9 JFK   MCO    2013     1     1          -3\n10 LGA   ORD    2013     1     1          -2\n# ℹ 336,766 more rows\n\n\nHvis vi lige kigger på flights_reduced med head() kan vi konstatere at variablene stadig har de engelske navme\n\nflights_reduced %&gt;% head()\n\n# A tibble: 6 × 6\n  origin dest   year month   day dep_delay\n  &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;\n1 EWR    IAH    2013     1     1         2\n2 LGA    IAH    2013     1     1         4\n3 JFK    MIA    2013     1     1         2\n4 JFK    BQN    2013     1     1        -1\n5 LGA    ATL    2013     1     1        -6\n6 EWR    ORD    2013     1     1        -4\n\n\nHvis vi gerne vil tage en smutvej til det samme, kan man faktisk godt bruge select() til både at udvælge og omdøbe kolonner. Denne gang assigner vi outputet til et objekt som vi kalder det samme som før (dvs. vi overskriver det gamle)\n\nflights_reduced &lt;- flights_reduced %&gt;% select(fra = origin, til = dest, år = year, måned = month, dag = day, forsinkelse = dep_delay)\nflights_reduced %&gt;% head()\n\n# A tibble: 6 × 6\n  fra   til      år måned   dag forsinkelse\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;\n1 EWR   IAH    2013     1     1           2\n2 LGA   IAH    2013     1     1           4\n3 JFK   MIA    2013     1     1           2\n4 JFK   BQN    2013     1     1          -1\n5 LGA   ATL    2013     1     1          -6\n6 EWR   ORD    2013     1     1          -4\n\n\nFunktionen/verbet mutate() er anden vigtig funktion som vi skal bruge hele tiden. Med mutate() kan vi ‘ændre’ vores dataobjekt, fx. lave nye variable eller omskrive gamle. lad os sige vi gerne vil have en ny variabel der fortæller os om et fly er mere end en halv time forsinket. Her skriver vi navnet på den variable vi vil lave og fortæller hvad den skal bestå af. Med forsinkelse &gt; 30 laver vi en logisk variabel der TRUE hvis forsinkelsen er over 30 min ellers FALSE.\n\nflights_reduced &lt;- flights_reduced %&gt;% mutate(forsinket_halv_time = forsinkelse &gt; 30)\nflights_reduced %&gt;% head()\n\n# A tibble: 6 × 7\n  fra   til      år måned   dag forsinkelse forsinket_halv_time\n  &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt; &lt;lgl&gt;              \n1 EWR   IAH    2013     1     1           2 FALSE              \n2 LGA   IAH    2013     1     1           4 FALSE              \n3 JFK   MIA    2013     1     1           2 FALSE              \n4 JFK   BQN    2013     1     1          -1 FALSE              \n5 LGA   ATL    2013     1     1          -6 FALSE              \n6 EWR   ORD    2013     1     1          -4 FALSE              \n\n\nNu har vores dataobjekt fået en ny variabel.\n\n\nGrupper og ‘opsummeringer’\nHvis vi ikke bare vil ændre eller tilføje variable, men i stedet vil lave nogle beregninger på vores data, kan vi bruge verbet summarise(). Det kunne være vi gerne vil have den gennemsnitlige mean() forsinkelse på alle fly, og antallet af fly i det hele taget n() (tæller antal rækker), og antallet af fly, der er mere end en halv time forsinket:\n\nflights_reduced %&gt;% summarise(gens_forsinkelse = mean(forsinkelse), fly = n(), halv_time = sum(forsinket_halv_time))\n\n# A tibble: 1 × 3\n  gens_forsinkelse    fly halv_time\n             &lt;dbl&gt;  &lt;int&gt;     &lt;int&gt;\n1               NA 336776        NA\n\n\nHov!!! Hvorfor får vi værdien NA. Det skyldes at der åbenbart er flyafgange i data, hvor der ikke er registretet en tid. NA er (en af) R’s måde(r) at håndtere missing værdier. Hvis vi gerne vil lave vores beregninger alligevel, skal vi specificere at der skal ses bort fra missing-værdier. Det gør vi ved at skrive na.rm = TRUE (læses som na.remove) i mean() og sum() funktionern. Lad os i den forbindelse også lige tilføje en beregning af andelen af fly der er mere end en halv tinme forsinket:\n\nflights_reduced %&gt;% summarise(gens_forsinkelse = mean(forsinkelse, na.rm = T),  fly = n(), halv_time = sum(forsinket_halv_time, na.rm = T), halv_time_pct = halv_time / fly)\n\n# A tibble: 1 × 4\n  gens_forsinkelse    fly halv_time halv_time_pct\n             &lt;dbl&gt;  &lt;int&gt;     &lt;int&gt;         &lt;dbl&gt;\n1             12.6 336776     48291         0.143\n\n\nEn sidste funktion der vil dukke op hele tiden er group_by(). Vi har lige opsummeret hele datasættet. Vi kunne jo i stedet være interesseret i at gruppere data før vi opsummerer. Det kunne fx være på måneder. Altså gennemsnitlig forsinkelse per måned. For at gøre det skal vi sætte verbet/funktionen group_by() ind før summarise(). Bemærk her at vi kan (men behøver ikke) lave linjeskift i koden efter en pipe.\n\nflights_reduced %&gt;% \n  group_by(måned) %&gt;% \n  summarise(gens_forsinkelse = mean(forsinkelse, na.rm = T),  fly = n(), halv_time = sum(forsinket_halv_time, na.rm = T), halv_time_pct = halv_time / fly) %&gt;% \n  head(12)\n\n# A tibble: 12 × 5\n   måned gens_forsinkelse   fly halv_time halv_time_pct\n   &lt;dbl&gt;            &lt;dbl&gt; &lt;int&gt;     &lt;int&gt;         &lt;dbl&gt;\n 1     1            10.0  27004      3350        0.124 \n 2     2            10.8  24951      3182        0.128 \n 3     3            13.2  28834      4309        0.149 \n 4     4            13.9  28330      4531        0.160 \n 5     5            13.0  28796      4416        0.153 \n 6     6            20.8  28243      5717        0.202 \n 7     7            21.7  29425      6173        0.210 \n 8     8            12.6  29327      4238        0.145 \n 9     9             6.72 27574      2419        0.0877\n10    10             6.24 28889      2697        0.0934\n11    11             5.44 27268      2388        0.0876\n12    12            16.6  28135      4871        0.173 \n\n\nMan kan også gruppere data ud fra mere end en variabel. Vi kunne fx se på hvilke stærkninger, altså fra til, der er mest forsinkede. Her introduceres desuden en anden meget anvendlig funktion, nemlig arrange(), der sorterer data på en given variabel. Hvis vi bruger desc() omkring variable sorterer den faldende (dvs. fra størt til mindst, ellers sorterer den altid fra mindst til størst):\n\nflights_reduced %&gt;% \n  group_by(fra, til) %&gt;% \n  summarise(gens_forsinkelse = mean(forsinkelse, na.rm = T),  fly = n(), halv_time = sum(forsinket_halv_time, na.rm = T), halv_time_pct = halv_time / fly) %&gt;% \n  arrange(desc(gens_forsinkelse))\n\n`summarise()` has grouped output by 'fra'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 224 × 6\n# Groups:   fra [3]\n   fra   til   gens_forsinkelse   fly halv_time halv_time_pct\n   &lt;chr&gt; &lt;chr&gt;            &lt;dbl&gt; &lt;int&gt;     &lt;int&gt;         &lt;dbl&gt;\n 1 EWR   TYS               41.8   323       121         0.375\n 2 EWR   CAE               36.3   104        33         0.317\n 3 EWR   TUL               34.9   315       112         0.356\n 4 LGA   SBN               31.3     6         3         0.5  \n 5 EWR   OKC               30.6   346       112         0.324\n 6 LGA   BHM               29.8   296        88         0.297\n 7 LGA   CAE               29.5    12         4         0.333\n 8 EWR   DSM               29.3   411       121         0.294\n 9 EWR   JAC               28.7    23         6         0.261\n10 EWR   ROC               27.9   513       147         0.287\n# ℹ 214 more rows\n\n\nDet er åbenbart forbindelsen fra Newark Liberty International Airport til McGhee Tyson Lufthavn der oplever mest forsinkelse. I gennemsnit ca. 42 min og 37.5% er mere end en halv time forsinket…\n\n\n\n\n\n\nNote\n\n\n\nTake-away\nHer har vi set på hvordan vi indlæser data med read_csv(), og hvordan vi assigner data til et objekt med &lt;-. Vi har også introduceret %&gt;% - pipen - som vi sender videre fra vensstre mod højre. Vi har desuden set på funktionaliteten i dplyr:\nAf række-funktioner har vi introduceret filter(), som bruges til at udvælge specifikke rækker baseret på logiske betingelser &gt;, &lt;, ==, !=, eller kombinationer af disse med &, |.\nAf kolonne-funktioner har vi introduceret select() og rename(), til at udvælge og eller omdøbe variable. Desuden har vi snuset til mutate()-funktionen som vi bruger til at ændre eller tilføje variable.\nPå gruppe-niveauet har vi introduceret summarise() som for sig selv tilader opsummerende beregniger over hele data (opfattet som én gruppe), men som i kombination med group_by() kan lave opsummeringer baseret på en eller flere variable, der grupperer data."
  },
  {
    "objectID": "Install_guide.html#opsætning-af-r-og-rstudio",
    "href": "Install_guide.html#opsætning-af-r-og-rstudio",
    "title": "Setting up (or updating) R and RStudio",
    "section": "Opsætning af R og RStudio",
    "text": "Opsætning af R og RStudio\nDet første I skal gøre er at sikre jer at alle har den samme, seneste, version af R og RStudio installeret. Mange af jer har formentlig taget et statistikkursus af en eller anden art, hvor I har installeret R og RStudio. Men… hvis I ikke har brugt det siden eller ikke har opdateret programmerne er de formentlig forældede og erstattet af nye. Der kommer nye versioner hele tiden. Lad os derfor slette/afinstallere de gamle versioner først.\n\nHvis du aldrig har installeret R eller RStudio på din computer kan du springer over denne del og hoppe direkte videre til Installér R\n\n\nAfinstallér R og RStudio\n\nFor MacOs brugere\nDet er relativt simpelt at afinstallere R og RStudio. Gå til din applications folder og flyt RStudio til trash ved at højre-klikke på applications ikonet. Gør det samme for R applicationen.\n\n\n\nSlet RStudio på Mac\n\n\n\n\n\nSlet R på Mac\n\n\n\n\nFor Windows brugere\nAt afinstallere de to programmer i Windows er også relativt simpelt. Gå til ‘Apps & features’, som findes ‘settings’. Her finder du en liste over alle apps/programmer på din computer. “R for Windows (version number)” og RStudio og afinstallér dem. Se de to screenshots.\n\n\n\nSlet RStudio på Windows 10\n\n\n\n\n\nSlet R på Windows 10\n\n\n\n\n\nInstallér R\nDownload den seneste version af R fra cran. Vælg dit styresystem:\n\nHvis du er på en windows computer, klik på ‘base’ og på ‘Download R X.X.X for Windows’ (i stedet for X.X.X vil der være tal som indikere versionen, den nyeste)\nHvis du er på en Mac, klik på .pkg-filen under ‘latest release’, som hedder noget i retning af R-X.X.X.pkg, ligesom windows-versionen. Her skal I vide om I har en ældre eller nyere Mac (ca. før og efter 2020).\nHvis du er på en Linux computer, kan du følge denne guide.\n\nThen install the programming language. You don’t need to adapt the default install options during installation.\n\n\n\n\n\n\nNote\n\n\n\nBemærk at den version af R vi bruger i dette kursus er R version 4.5.2 (2025-10-31).\n\n\n\n\nInstallér RStudio\nNår du har installeret R, er næste skridt at installere RStudio. Følg dette link til RStudio. Almindeligvis vil hjemmesiden allerede have registretet dit styre system og du kan bare klikke download og fortsætte.\nHvis ikke, så scroll ned på siden, hvor der findes en list af download links til forskellige styresystemer.\n\n\n\n\n\n\n\nOptions på https://posit.co/download/rstudio-desktop/\n\n\n\n\n\n\n\n\nNote\n\n\n\nBemærk at den version af Rstudio vi bruger i dette kursus er -2026.01.0-392.\n\n\n\n\nKlar, parat, start!\nNu skulle R og RStudio gerne være opdateret/installeret på jeres computere og vi er klar til at komme i gang med at skrive og læse kode.\nInden vi går videre skal I have downloadet zip-filen med r-projektet virkstrat_netvaerk her:\nDownload Data\neller fra kursets canvas-side.\nDen fil indeholder følgende filer og mapper:\n\n\n\nIndhold af zip-filen\n\n\n(og skal i øvrigt opdateres med filer, jeg løbende lægger op på Canvas):\nDownload zip-filen og pak den ud et fornuftigt sted på jeres harddisk (så I ved hvor I har den), det kunne fx. være i den mappe i har jeres andre studierelevante ting i, så som noter o.l.\nHvis I sørger for altid at åbne virkstrat_netvaerk.Rproj filen enten ved at dobbeltklikke på den, eller åbne den inde fra R-studio øverste højre hjørne (hvor den vil ligge som ‘recent projects’ hvis den har været åbnet før). Hvis ikke skal I finde den under open project… (hvor I ‘browser’ jer frem til der hvor filen ligger).\nVi ses Jacob"
  },
  {
    "objectID": "session2.html",
    "href": "session2.html",
    "title": "Sammenhængskraft, Densitet, kliker og strukturelle huller",
    "section": "",
    "text": "library(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nlibrary(Matrix)\n\n\nAttaching package: 'Matrix'\n\nThe following objects are masked from 'package:tidyr':\n\n    expand, pack, unpack\n\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\nThe following objects are masked from 'package:lubridate':\n\n    %--%, union\n\nThe following objects are masked from 'package:dplyr':\n\n    as_data_frame, groups, union\n\nThe following objects are masked from 'package:purrr':\n\n    compose, simplify\n\nThe following object is masked from 'package:tidyr':\n\n    crossing\n\nThe following object is masked from 'package:tibble':\n\n    as_data_frame\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(ggraph)"
  },
  {
    "objectID": "session2.html#data-det-danske-elitenetværk",
    "href": "session2.html#data-det-danske-elitenetværk",
    "title": "Sammenhængskraft, Densitet, kliker og strukturelle huller",
    "section": "Data: Det danske elitenetværk",
    "text": "Data: Det danske elitenetværk\n\nden &lt;- read_csv(\"data/den17-no-nordic-letters.csv\")\n\nVha funktionen show.all.tags() fra custom_functions.R i functionsmappen, kan vi studere og udvælge specifikke tags, vi synes skal med for at indfange et bestemt område: Download costumfunctions.R her\n\nsource(\"functions/custom_functions.R\")\nhead(show.all.tags(den), 25)\n\n                               Positions affiliations\nA-kasse                              193           14\nAcademics                            927           71\nActors                                65            7\nAdministration                       789           66\nAfrica                                13            1\nAlternative                           45            8\nAnimals                              397           50\nArchitecture                        1419          130\nArt                                  753          100\nArtists                              245           30\nAsia                                   5            1\nAward                                 40            6\nBaltic countries                      11            2\nBanks                                899           69\nBILH                                 190           45\nBlood donation                        72            5\nBoard of representatives             846           15\nBoarding school                       27            2\nBorgerloen                            11            1\nBrazil                                 5            1\nBusiness                            1665          114\nBusiness and Financial Affairs        86           12\nBusiness association                3627          343\nBYGG                                 282           43\nCancer                                96            9"
  },
  {
    "objectID": "session2.html#subset-tags",
    "href": "session2.html#subset-tags",
    "title": "Sammenhængskraft, Densitet, kliker og strukturelle huller",
    "section": "Subset: Tags",
    "text": "Subset: Tags\nLad os i det følgende kigge på mødesteder, e.g. bestyrelser, råd, nævn m.v., i det danske elitenetværk (2017), der tematisk kan siges at udgøre transportområdet. Det gør vi vha. has.tags() funktionen i custom_functions.R\n\ntransport &lt;- c(\"BILH\",\"Cars\", \"Public transport\", \"TRAN\", \"Transport\", \"Traffic\", \"Infrastructure\", \"VL\", \"Roads\")\nden_sub   &lt;- has.tags(den, tags = transport, result = \"den\", mode = \"or\")\n\n                 Matched positions\nBILH                           190\nCars                           126\nPublic transport                97\nTRAN                           236\nTransport                      578\nTraffic                         17\nInfrastructure                 298\nVL                            3803\nRoads                           39\n\n \n\n\n\nden_sub &lt;- den_sub %&gt;% group_by(name) %&gt;% mutate(n_afil = n_distinct(affiliation))\nden_sub &lt;- den_sub %&gt;% filter(n_afil &gt; 1)"
  },
  {
    "objectID": "session2.html#grafobjekt",
    "href": "session2.html#grafobjekt",
    "title": "Sammenhængskraft, Densitet, kliker og strukturelle huller",
    "section": "Grafobjekt",
    "text": "Grafobjekt\nVi laver en sparse incidence eller bipartite adjacency matrix. Dvs en matrice med individer (name) i rækker og virksomheder m.v. (affiliation) i kolonner:\n\nbi_adj &lt;- xtabs(formula = ~ name + affiliation, data = den_sub, sparse = TRUE)\n\nOg laver vha matrix multiplikation \\(individ \\times individ\\) matricen:\n\nadj &lt;-  bi_adj %*% t(bi_adj)\n\nJeg vil gerne vide hvilke værdier vores matrice indeholder. Så jeg kan overveje om den er vægtet eller ej. Da det er en sparse matrice vi har lavet kan vi dog ikke lave en simple table(). str() fortæller os hvad dataobjektet indeholder.\n\nstr(adj)\n\nFormal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  ..@ i       : int [1:1552] 0 18 23 1 121 2 40 58 85 96 ...\n  ..@ p       : int [1:203] 0 3 5 14 21 27 31 41 47 55 ...\n  ..@ Dim     : int [1:2] 202 202\n  ..@ Dimnames:List of 2\n  .. ..$ name: chr [1:202] \"Agner Holmbjerg\" \"Allan Junge\" \"Allan Linneberg-Agerholm\" \"Anders Egehus\" ...\n  .. ..$ name: chr [1:202] \"Agner Holmbjerg\" \"Allan Junge\" \"Allan Linneberg-Agerholm\" \"Anders Egehus\" ...\n  ..@ x       : num [1:1552] 2 2 2 2 1 2 1 1 1 1 ...\n  ..@ factors : list()\n\n\n@x indeholder matrices værdier (ud over 0): Så kan vi tælle:\n\ntable(adj@x)\n\n\n   1    2    3    4    5    7 \n1078  444   23    5    1    1 \n\n\nDer er altså (444 + 23 + 5 + 1 + 1 = 474) / 2 individer, der mødes mere end et sted. Så der er en mulighed for at lade edges være vægtede. I dette eksempel vælger jeg at se bort fra vægten (dvs vi undlader at skrive weighted = TRUE).\n\ngr    &lt;- adj %&gt;% graph_from_adjacency_matrix(mode = \"undirected\", diag = FALSE) %&gt;% simplify()\ngr\n\nIGRAPH f49c1a0 UN-- 202 675 -- \n+ attr: name (v/c)\n+ edges from f49c1a0 (vertex names):\n [1] Agner Holmbjerg         --Bo Tarp                   \n [2] Agner Holmbjerg         --Carl Johan Hansen         \n [3] Allan Junge             --Lars Goth                 \n [4] Allan Linneberg-Agerholm--Dan Nissen                \n [5] Allan Linneberg-Agerholm--Hans Christian Munck 10772\n [6] Allan Linneberg-Agerholm--Jens Dalsgaard Loegstrup  \n [7] Allan Linneberg-Agerholm--Jesper Eigen Moeller      \n [8] Allan Linneberg-Agerholm--Joergen Groth Dirksen     \n+ ... omitted several edges\n\n\n\ngr %&gt;% ggraph() +\n  geom_edge_link0(edge_width = 0.3, edge_alpha = .5) +\n  geom_node_point() +\n  theme_graph()\n\nUsing \"stress\" as default layout"
  },
  {
    "objectID": "session2.html#densitet-edge_density",
    "href": "session2.html#densitet-edge_density",
    "title": "Sammenhængskraft, Densitet, kliker og strukturelle huller",
    "section": "Densitet: edge_density()",
    "text": "Densitet: edge_density()\nDet mest simple og intuitive mål for ‘sammenfiltrethed’ er at udtrykke det faktiske antal af forbindelser i et netværk som en andel af de teoretisk mulige.\nLad os sige vi har et netværk med \\(n=25\\) individer. Hvis alle har en forbindelse til alle vil der være: \\[n \\times (n-1)\\] forbindelser, hvis forbindelserne er retningsbestemte, så \\(A \\rightarrow B \\nRightarrow A \\leftarrow B\\), dvs. forbindelsen A-B medfører ikke nødvendigvis forbindelsen B-A.\nog \\[(n \\times (n-1)) \\over 2\\] forbindelser, hvis forbindelserne er symmetriske per definition, \\(A - B = B-A\\).\nDet kalder vi det teoretiske max og densiteten er således: \\[\n{E \\over n \\times (n-1)} \\quad \\text{eller} \\quad {2E \\over n \\times (n-1)}, \\quad \\text{hvor er det faktiske antal forbindelser}\n\\]\n\n\n\n\n\n\n\n\n\n\ntransitivity(largest_component(gr))\n\n[1] 0.6948424\n\n\nDownload nye funktioner her"
  }
]